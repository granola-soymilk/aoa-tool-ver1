<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <title>Antwerp On Air Generator…</title>
    <style>        
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top instead of center */
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
            padding-top: 70px;
            overflow-x: auto; /* Allow horizontal scrolling if needed */
            font-family: 'YourCustomFont1', system-ui, sans-serif;
            
        }

        .main-container {
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping */
            gap: 20px;
            max-width: 100%;
            align-items: flex-start;
        }

        .left-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
        }

        .left-controls-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 250px;
        }

        .left-controls-section input {
            padding: 6px;
            margin-bottom: 8px;
            width: 100%;
            font-size: 14px;
            box-sizing: border-box;
            font-family: 'YourCustomFont1';
            color: black;
        }

        .left-controls-section label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: black;
            font-family: 'YourCustomFont1';
        }

        .controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 400px;
            flex-shrink: 0;
        }

        .controls input {
            padding: 6px;
            margin-bottom: 8px;
            width: 100%;
            font-size: 14px;
            box-sizing: border-box;
            font-family: 'YourCustomFont1';
            color: black;
        }

        .controls label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: black;
            font-family: 'YourCustomFont1';
        }

        .controls button {
            padding: 6px 12px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }

        .controls button:hover {
            background: #333333;
        }

        .controls .range-container {
            margin-bottom: 12px;
            position: relative;
        }
        
        .controls .range-container .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: black;
            font-family: 'YourCustomFont1';
        }

        .controls .range-container input[type="range"] {
            position: relative;
        }

        .controls .range-container input[type="range"]::after {
            content: attr(value) 'px';
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 12px;
            color: #666;
        }

        .controls input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
        }

        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            margin-top: -6px;
        }

        .controls input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        .controls input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        .controls input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        .controls input[type="range"]::-ms-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .controls input[type="range"]::-ms-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        /* Common style for all text inputs in both control panels */
        .controls input[type="text"],
        .left-controls input[type="text"] {
            padding: 6px;
            margin-bottom: 8px;
            width: 100%;
            font-size: 14px;
            box-sizing: border-box;
            font-family: 'YourCustomFont1';
            color: black;
            border: 1px solid #ccc;  /* Consistent border color */
            border-radius: 4px;      /* Consistent border radius */
        }

        /* Specific styling for color inputs while maintaining the common style */
        .controls input[type="text"][id$="ColorInput"] {
            padding-left: 36px;
            position: relative;
            background: linear-gradient(to right, 
                var(--input-color, #000) 0px,
                var(--input-color, #000) 30px,
                transparent 30px
            );
        }

        /* Text inputs in left-controls */
        .left-controls input[type="text"] {
            border: 1px solid #ccc;  /* Match the border color */
            border-radius: 4px;      /* Match the border radius */
        }

        #strokeColorInput {
            --input-color: var(--stroke-color, #a540ce);
        }

        #letterColorInput {
            --input-color: var(--letter-color, #000000);
        }

        #backgroundColorInput {
            --input-color: var(--background-color, #FFFFFF);
        }

        .controls input[type="file"] {
            margin-bottom: 8px;
            width: 100%;
            font-size: 14px;
        }

        #removeImageBtn {
            margin-bottom: 12px;
            background: #000000;
        }

        #removeImageBtn:hover {
            background: #333333;
        }

        .controls input[type="checkbox"] {
            width: auto;
            margin-bottom: 8px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid black;
            border-radius: 3px;
            position: relative;
            outline: none;
        }

        .controls input[type="checkbox"]:checked {
            background-color: black;
        }

        .controls input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            left: 4px;
            top: 1px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .controls label[for="ditherToggle"] {
            margin-bottom: 4px;
        }

        .toggle-container {
            display: flex;
            gap: 20px;
            margin-bottom: 12px;
        }

        .toggle-group {
            flex: 1;
        }

        .range-container.with-margin {
            margin-top: 10px;
        }

        .label-with-margin {
            margin-top: 10px;
        }

        .range-container.lower-position {
            position: relative;
            top: 10px;
        }

        .label.lower-position {
            position: relative;
            top: 10px;
        }

        .left-controls button {
            padding: 6px 12px;
            background: #000000;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-bottom: 12px;
        }

        .left-controls button:hover {
            background: #333333;
        }

        .left-controls input[type="file"] {
            margin-bottom: 8px;
            width: 100%;
            font-size: 14px;
        }

        #removeFloatingImageBtn {
            margin-bottom: 12px;
            background: #000000;
        }

        #removeFloatingImageBtn:hover {
            background: #333333;
        }

        .left-controls .range-container {
            margin-bottom: 12px;
            position: relative;
        }

        .left-controls .range-container .range-values {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: black;
            font-family: 'YourCustomFont1';
        }

        .left-controls .range-container input[type="range"] {
            position: relative;
        }

        .left-controls input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
            width: 100%;
        }

        .left-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            margin-top: -6px;
        }

        .left-controls input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        .left-controls input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
            border: none;
        }

        .left-controls input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        .left-controls input[type="range"]::-ms-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: black;
            cursor: pointer;
        }

        .left-controls input[type="range"]::-ms-track {
            width: 100%;
            height: 4px;
            background: #ddd;
        }

        /* Add specific styling for the floating image size controls */
        #floatingImageSizeInput,
        label[for="floatingImageSizeInput"],
        #floatingImageSizeValue {
            margin-top: 0px;
        }

        .left-controls label:has(+ .range-container #floatingImageSizeInput) {
            margin-top: 15px;
        }

        #exportBtn {
            margin-top: 20px;
        }

        .color-input-container {
            margin-bottom: 12px;
        }

        .color-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-input-group input[type="color"] {
            width: 40px;
            height: 40px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-input-group input[type="text"] {
            flex: 1;
        }

        #randomColorSchemeBtn {
            background: linear-gradient(45deg, #FF4B1F, #24ABFF);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-bottom: 10px;
            transition: opacity 0.3s;
        }

        #randomColorSchemeBtn:hover {
            opacity: 0.9;
        }

        .hidden-control {
            display: none !important;
        }

        .font-select-container {
            margin-bottom: 12px;
        }

        .font-select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
        }

        .font-select option {
            padding: 8px;
            font-size: 14px;
        }

        #myCanvas {
            max-width: 100%;
            max-height: 80vh;
            display: block;
        }

        @font-face {
            font-family: 'YourCustomFont1';
            src: url('MonaSans-Medium.ttf') format('truetype');
        }
        
        @font-face {
            font-family: 'YourCustomFont2';
            src: url('fonts/OffBitTrial-101.ttf') format('truetype');
        }

        

        .section-label {
            background: black;
            color: white;
            padding: 15px 15px;  /* Match the left-controls padding */
            margin: -15px -15px 15px -15px;  /* Negative margins to extend to edges */
            border-radius: 4px 4px 0 0;  /* Top-left, top-right, bottom-right, bottom-left */
            font-family: 'YourCustomFont1';
            font-size: 16px;
            font-weight: bold;
        }

        /* Add styles for bottom-controls */
        .bottom-controls {
            position: relative;
            display: flex;
            justify-content: center;
            margin-top: 20px;
            box-sizing: border-box;
            
        }

        .bottom-controls-section {
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            box-sizing: border-box;
            font-size: 12px;
            

        }


        #randomColorSchemeBtn:hover {
            opacity: 0.9;
        }
    
        /* Ensure canvas container properly constrains its children */
        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 1; /* Allow canvas to shrink if needed */
            min-width: 0; /* Allow container to shrink below content size */
        }

        #myCanvas {
            max-width: 100%;
            max-height: 80vh;
            display: block;
        }


        /* Make all buttons in bottom controls have consistent styling */
        .bottom-controls-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px; /* Reduced from 20px to 10px to give more space for each button */
            margin-bottom: 5px;
            width: 100%;
        }

        /* Add media query for smaller screens */
        @media (max-width: 1200px) {
            .main-container {
                justify-content: flex-start; /* Left-align when space is tight */
            }
            
            #myCanvas {
                max-width: calc(100vw - 600px); /* Adjust canvas size to leave room for panels */
            }
        }

        /* Add styling for the color scheme select dropdown */
        #colorSchemeSelect {
            flex: 1;
            height: 45px;
            margin-top: 10px;
            padding: 8px 15px;
            font-size: 14px;
            color: white;
            background: linear-gradient(45deg, #67FC04, #ED82D4);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'YourCustomFont1'
        }

        #colorSchemeSelect:hover {
            background: #333;
        }

        #colorSchemeSelect option {
            background: white;
            color: black;
        }


        /* Add styles for the new column layout */
        .bottom-controls-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        /* Update button styling to work with new layout */
        .bottom-controls-buttons button {
            flex: 1;
            font-family: 'YourCustomFont1';
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            color: white;
            margin-top: 10px;
            text-align: center;
            min-width: 0;
            line-height: 20px; /* Control text vertical alignment */
            box-sizing: border-box;
            font-size: 12px;
            background: #000000;
            
        }

        .bottom-controls-buttons button:hover {
            background: #333333;
        }

        /* Add new styles for countdown and recording indicator */
        .countdown-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1000;
            
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: red;
            animation: blink 1s infinite;
            display: none;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="ffmpeg_asm.js"></script>
</head>
<body>
    <div class="main-container">
        <div class="left-controls">
            <div class="left-controls-section">
                <div class="section-label">IMAGE SETTINGS</div>
                <label>Background Image</label>
                <input type="file" id="imageInput" accept="image/*">
                <button id="removeImageBtn">Remove Background</button>
                <label>Floating Image</label>
                <input type="file" id="floatingImageInput" accept="image/*">
                <button id="removeFloatingImageBtn">Remove Floating Image</button>
                
                <label>Floating Image Size <span id="floatingImageSizeValue">0.3</span>x</label>
                <div class="range-container">
                    <input type="range" id="floatingImageSizeInput" min="0.1" max="1.0" value="0.3" step="0.05">
                </div>
            </div>

            <div class="left-controls-section">
                <div class="section-label">TEXT SETTINGS</div>
                <label>Header</label>
                <input type="text" id="headerTextInput" placeholder="Enter header text..." value="ANTWERP">
                <label>Header Line 2</label>
                <input type="text" id="headerText2Input" placeholder="Enter second header text..." value="ON AIR">

                <label>Right Header Line 1</label>
                <input type="text" id="rightHeaderTextInput" placeholder="Enter right header text..." value="4 SEPT">
                <label>Right Header Line 2</label>
                <input type="text" id="rightHeaderText2Input" placeholder="Enter second right header text..." value="2025">

                <label>Footer Line 1</label>
                <input type="text" id="footer2TextInput" placeholder="Enter first footer text..." value="MEIR">
                <label>Footer Line 2</label>
                <input type="text" id="footerTextInput" placeholder="Enter second footer text..." value="ANTWERP">

                <div class="font-select-container hidden-control">
                    <label>Custom Font</label>
                    <select id="fontSelect" class="control-input">
                        <option value="Arial">Arial</option>
                        <option value="Impact">Impact</option>
                        <option value="Verdana">Verdana</option>
                        <option value="YourCustomFont1">Mona Sans</option>
                        <option value="YourCustomFont2">Offbit</option>
                        <!-- Add more fonts as needed -->
                    </select>
                </div>

                <div class="font-select-container">
                    <label>Aspect Ratio</label>
                    <select id="aspectRatioSelect" class="font-select">
                        <option value="1:1">1:1 Square</option>
                        <option value="4:5">4:5 Portrait</option>
                        <option value="9:16">9:16 Portrait</option>
                        <option value="16:9">16:9 Landscape</option>
                    </select>
                </div>

            </div>
        </div>
        
        <div class="canvas-container">
            <!-- Add a container for both canvas and SVG -->
            <div class="canvas-wrapper" style="position: relative;">
                <canvas id="myCanvas" width="600" height="600"></canvas>
                <!-- Removing the SVG overlay div -->
            </div>
            
            <div class="bottom-controls">
                <div class="bottom-controls-section">
                    <div class="bottom-controls-buttons">
                        <div class="bottom-controls-column">
                            <button id="resetBtn"><i class="fa-solid fa-arrows-rotate"></i>&nbsp; &nbsp;Reset Animation</button>
                            <button id="pauseButton" class="control-button"><i class="fa-solid fa-pause"></i>&nbsp; &nbsp;Pause Animation</button>
                        </div>
                        <div class="bottom-controls-column">
                            <button id="exportButton" class="control-button"><i class="fa-solid fa-image"></i>&nbsp; &nbsp;Export JPG</button>
                            <div style="display: flex; gap: 5px;">
                                <button id="exportButtonVideo" class="control-button">Custom MP4</button>
                                <button id="quickExportButton" class="control-button">Quick MP4</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="section-label">FLOATING TEXT SETTINGS</div>
            
            <!-- Text inputs in the right controls -->
            <label>First</label>
            <input type="text" id="textInput" placeholder="Enter text..." value="ANTWERP" style="font-family: 'YourCustomFont1';">
            <label>Second</label>
            <input type="text" id="secondTextInput" placeholder="Enter second text..." value="ON" style="font-family: 'YourCustomFont1';">
            <label>Third</label>
            <input type="text" id="thirdTextInput" placeholder="Enter third text..." value="AIR" style="font-family: 'YourCustomFont1';">
            
            <div class="color-input-container hidden-control">
            <label>Background Color</label>
                <div class="color-input-group">
                    <input type="color" id="backgroundColorPicker" value="#242AD6">
                    <input type="text" id="backgroundColorInput" placeholder="#242AD6" value="#242AD6">
                </div>
            </div>

            <div class="color-input-container hidden-control">
            <label>Letter Color</label>
                <div class="color-input-group">
                    <input type="color" id="letterColorPicker" value="#24ABFF">
                    <input type="text" id="letterColorInput" placeholder="#24ABFF" value="#24ABFF">
                </div>
            </div>

            <label class="label lower-position">Letter Size <span id="letterSizeValue">89</span>px</label>
            <div class="range-container lower-position">
                <input type="range" id="letterSizeInput" min="20" max="200" value="89">
            </div>
            
            <label class="label-with-margin hidden-control">Random Size Range <span id="randomSizeValue">0</span>px</label>
            <div class="range-container with-margin hidden-control">
                <input type="range" id="randomSizeInput" min="0" max="100" value="0" step="25">
            </div>

            <label>Stroke Width <span id="strokeWidthValue">15</span>px</label>
            <div class="range-container">
                <input type="range" id="strokeWidthInput" min="1" max="20" value="15" step="1">
            </div>

            <label class="hidden-control">Letter Floating Speed <span id="oscillationSpeedValue">0.5</span>x</label>
            <div class="range-container hidden-control">
                <input type="range" id="oscillationSpeedInput" min="0" max="3" value="0.5" step="0.1">
                    </div>

            <label class="hidden-control">Word Floating Speed <span id="wordOscillationValue">1</span>x</label>
            <div class="range-container hidden-control">
                <input type="range" id="wordOscillationInput" min="0" max="3" value="1" step="0.1">
            </div>

            <label class="hidden-control">Spring Stiffness <span id="springStiffnessValue">0.01</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="springStiffnessInput" min="0.001" max="0.05" value="0.01" step="0.001">
                    </div>

            <label class="hidden-control">Spring Damping <span id="springDampingValue">0.1</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="springDampingInput" min="0.05" max="0.3" value="0.1" step="0.01">
            </div>

            <label class="hidden-control">Balloon Bounciness <span id="bouncinessValue">0</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="bouncinessInput" min="0" max="0.001" value="0" step="0.0001">
            </div>

            <label class="hidden-control">Air Friction <span id="airFrictionValue">0.2</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="airFrictionInput" min="0.1" max="0.5" value="0.2" step="0.01">
            </div>

            <label>Turbulence <span id="turbulenceValue">0.2</span>x</label>
            <div class="range-container">
                <input type="range" id="turbulenceInput" min="0" max="2" value="0.2" step="0.1">
            </div>

            <div class="color-input-container hidden-control">
                <label>Funky Stroke Color</label>
                <div class="color-input-group">
                    <input type="color" id="funkyStrokeColorPicker" value="#FF4B1F">
                    <input type="text" id="funkyStrokeColorInput" placeholder="#FF4B1F" value="#FF4B1F">
                </div>
            </div>

            <label class="hidden-control">Funky Stroke Scale <span id="funkyStrokeWidthValue">1</span>x</label>
            <div class="range-container hidden-control">
                <input type="range" id="funkyStrokeWidthInput" min="0" max="5" value="1" step="0.1">
            </div>

            <label class="hidden-control">Funky Effect</label>
            <select id="funkyEffectSelect" class="hidden-control">
                <option value="wave">Wave</option>
            </select>

            <label class="hidden-control">Funky Spikiness <span id="funkySpikynessValue">1</span>x</label>
            <div class="range-container hidden-control">
                <input type="range" id="funkySpikynessInput" min="0" max="5" value="1" step="0.1">
            </div>

            <label class="hidden-control">Wave Frequency <span id="waveFrequencyValue">4</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="waveFrequencyInput" min="1" max="20" value="4" step="1">
            </div>

            <label class="hidden-control">Wave Depth <span id="waveDepthValue">1</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="waveDepthInput" min="0" max="5" value="1" step="0.1">
            </div>

            <label class="hidden-control">Wave Layers <span id="waveLayersValue">1</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="waveLayersInput" min="1" max="5" value="1" step="1">
            </div>

            <label class="hidden-control">Wave Phase Shift <span id="wavePhaseValue">0</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="wavePhaseInput" min="0" max="360" value="0" step="15">
            </div>

            <label class="hidden-control">Funky Roundness <span id="funkyRoundnessValue">0</span></label>
            <div class="range-container hidden-control">
                <input type="range" id="funkyRoundnessInput" min="0" max="50" value="0" step="1">
            </div>

            <div class="color-input-container hidden-control">
                <label>Triangle Color</label>
                <div class="color-input-group">
                    <input type="color" id="triangleColorPicker" value="#4AFF00">
                    <input type="text" id="triangleColorInput" placeholder="#4AFF00" value="#4AFF00">
                </div>
            </div>

            <div class="hidden-control">
                <label>Triangle Density <span id="triangleDensityValue">3</span></label>
                <div class="range-container">
                    <input type="range" id="triangleDensityInput" min="1" max="10" value="3" step="1">
                </div>

                <label>Triangle Rotation <span id="triangleRotationValue">0</span>°</label>
                <div class="range-container">
                    <input type="range" id="triangleRotationInput" min="0" max="360" value="0" step="15">
                </div>

                <label>Funky Stroke Size <span id="triangleSizeValue">20</span>px</label>
                <div class="range-container">
                    <input type="range" id="triangleSizeInput" min="0" max="100" value="0" step="1">
                </div>
            </div>

            <label>Shape Stroke Width <span id="shapeStrokeWidthValue">50</span>px</label>
            <div class="range-container">
                <input type="range" id="shapeStrokeWidthInput" min="25" max="60" value="60" step="1">
            </div>

            <label>Size Oscillation <span id="sizeOscillationValue">50</span>px</label>
            <div class="range-container">
                <input type="range" id="sizeOscillationInput" min="0" max="50" value="50" step="1">
            </div>

            <!-- First add the HTML slider after the turbulence slider -->
            <label>Inflate/Deflate <span id="inflateValue">0.00</span>x</label>
            <div class="range-container">
                <input type="range" id="inflateInput" min="-0.1" max="0.1" value="0.00" step="0.01">
            </div>

            <!-- Add this after one of your other sliders in the controls section -->
            <label>Outer Stroke Waviness <span id="outerStrokeWavinessValue">0.00</span>x</label>
            <div class="range-container">
                <input type="range" id="outerStrokeWavinessInput" min="0" max="0.2" value="0.00" step="0.01">
            </div>

            <button id="colorSchemeSelect">Color Scheme</button>
            
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const textInput = document.getElementById('textInput');
        let letters = textInput.value;
        const letterObjects = [];
        let animationFrame;
        let arranging = false;
        let pathPoints = [];
        let isDrawingPath = false;
        let hasDrawnPath = false;
        let backgroundImage = null;
        const secondTextInput = document.getElementById('secondTextInput');
        let secondLetters = secondTextInput.value;
        const secondLetterObjects = [];
        let secondPathPoints = [];
        let currentDrawingSet = 1; // Track which set we're currently drawing for
        const thirdTextInput = document.getElementById('thirdTextInput');
        let thirdLetters = thirdTextInput.value;
        const thirdLetterObjects = [];
        let thirdPathPoints = [];
        const logoSvg = new Image();
        logoSvg.crossOrigin = "anonymous";
        let isPaused = false;
        let pausedAnimationFrame = null;


        
        const pauseButton = document.getElementById('pauseButton');
        pauseButton.addEventListener('click', function() {
            isPaused = !isPaused;
            // Update to preserve the icon
            pauseButton.innerHTML = isPaused ? 
                '<i class="fa-solid fa-play"></i>&nbsp; &nbsp;Resume Animation' : 
                '<i class="fa-solid fa-pause"></i>&nbsp; &nbsp;Pause Animation';
            
            if (isPaused) {
                // Store the current animation frame and cancel it
                pausedAnimationFrame = animationFrame;
                cancelAnimationFrame(animationFrame);
                
                // Pause the physics engine
                engine.timing.timeScale = 0;
            } else {
                // Restore the physics engine
                engine.timing.timeScale = 1;
                
                // Resume animation if it was running
                if (pausedAnimationFrame) {
                    animate();
                }
            }
        });
        // Add load event listener
        logoSvg.onload = function() {
            // Force dimensions if they're not set
            if (this.naturalWidth === 0) {
                this.naturalWidth = 100;  // default width
                this.naturalHeight = 100; // default height
            }
            console.log('SVG loaded successfully:', {
                width: this.naturalWidth,
                height: this.naturalHeight
            });
        };

        // Add error event listener
        logoSvg.onerror = function(error) {
            console.error('Failed to load SVG:', error);
        };

        // Set the source AFTER adding event listeners

        logoSvg.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgNTAxLjg0IDQ5OC4wMyI+CiAgPGcgaWQ9IkxheWVyXzEtMiIgZGF0YS1uYW1lPSJMYXllcl8xIj4KICAgIDxnPgogICAgICA8cGF0aCBkPSJNNTAxLjczLDIyMy4yOGwtMjQuNjMtMTk2LjU0Yy0uOC02LjM2LTUuNTUtMTEuNTEtMTEuODItMTIuODJMNDAwLjExLjMyYy02LjI3LTEuMzEtMTIuNjksMS41MS0xNS45Niw3LjAybC04NC4yOCwxNDEuODdjLS4wOS0uMDMtLjE4LS4wNy0uMjYtLjEtMTIuNjgtNC44My0yNi42Ny03LjI3LTQxLjU4LTcuMjdzLTI4LjkyLDIuNDYtNDEuNTUsNy4zYy0xMC4wNCwzLjg1LTE5LjE2LDkuMDktMjcuMjIsMTUuNjRMMTE1LjYxLDUzLjY2Yy0zLjU0LTUuMzQtMTAuMDgtNy44NS0xNi4yOS02LjIzbC02NC40MiwxNi43OWMtNi4yLDEuNjItMTAuNjksNi45OS0xMS4xNywxMy4zOGwtMTQuOTMsMTk3LjUxYy0uMzcsNC44MywxLjYyLDkuNTQsNS4zNCwxMi42NSwzLjcyLDMuMSw4LjcxLDQuMjIsMTMuNCwzbDY4LjE1LTE3Ljc2YzYuMjktMS42NCwxMC44LTcuMTQsMTEuMTktMTMuNjJsMS4zOC0yMy4wOCwxMS4wNC0yLjg4LDEyLjQ2LDE5LjQ3YzMuNSw1LjQ3LDEwLjE0LDguMDcsMTYuNDIsNi40M2w0LjM0LTEuMTNjLjcyLDEyLjMzLDMuMDIsMjMuODcsNi44OCwzNC4zOCw1LjA3LDEzLjgyLDEyLjYzLDI1LjgyLDIyLjQ4LDM1LjY2LDkuNzIsOS43MiwyMS4zNiwxNy4yMywzNC42LDIyLjMsMTIuNjQsNC44NSwyNi42Miw3LjMxLDQxLjU2LDcuMzFzMjguOTItMi40Niw0MS41Ni03LjNjMTMuMTgtNS4wNSwyNC44MS0xMi41MSwzNC41Ny0yMi4xNyw5Ljk3LTkuODcsMTcuNjEtMjEuOTEsMjIuNy0zNS43OSw0LjczLTEyLjg5LDcuMTMtMjcuMyw3LjEzLTQyLjg0LDAtMTIuODYtMS42NC0yNC45Mi00LjktMzUuOTRsMi42Ny41NmM2LjM2LDEuMzIsMTIuODUtMS41OSwxNi4wOC03LjIzbDExLjQ5LTIwLjA2LDExLjE2LDIuMzMsMi41MSwyMi45OGMuNzEsNi40Niw1LjQ5LDExLjczLDExLjg1LDEzLjA2bDY4Ljk0LDE0LjM4YzQuNzQuOTksOS42Ny0uMzcsMTMuMjMtMy42NiwzLjU2LTMuMjgsNS4zMi04LjA5LDQuNzItMTIuODlaTTQzMS42MywxOTguM2wtMi41MS0yMi45OGMtLjcxLTYuNDYtNS40OS0xMS43My0xMS44NS0xMy4wNmwtMzIuNS02Ljc4Yy02LjM2LTEuMzMtMTIuODUsMS41OS0xNi4wOCw3LjIzbC0xMS40OSwyMC4wNi0yMS4zNS00LjQ1Yy02LjAxLTEuMjYtMTIuMTgsMS4yOC0xNS41Nyw2LjQtMy4zOSw1LjEyLTMuMzIsMTEuNzguMTcsMTYuODMsMy4zMSw0Ljc4LDYuMDgsMTAuMTEsOC4yMiwxNS44NiwzLjUyLDkuNDUsNS4zLDIwLjMzLDUuMywzMi4zNHMtMS43OCwyMi45NC01LjI5LDMyLjUxYy0zLjU2LDkuNzEtOC44MiwxOC4wNS0xNS42NCwyNC44LTYuNzksNi43Mi0xNC45MywxMS45My0yNC4yLDE1LjQ4LTkuMiwzLjUzLTE5LjU3LDUuMzItMzAuODIsNS4zMnMtMjEuNjItMS43OS0zMC44Mi01LjMyYy05LjI4LTMuNTYtMTcuNC04Ljc3LTI0LjEyLTE1LjUtNi43NC02Ljc0LTExLjk3LTE1LjA4LTE1LjUyLTI0Ljc4LTMuNTEtOS41Ni01LjI5LTIwLjUtNS4yOS0zMi41MSwwLTMuMzEuMTQtNi41OC40MS05LjcyLjQyLTQuODUtMS41NC05LjYxLTUuMjctMTIuNzUtMi43NC0yLjMxLTYuMTctMy41NC05LjY4LTMuNTQtMS4yNiwwLTIuNTMuMTYtMy43OC40OGwtMTIuOCwzLjM0LTEyLjQ2LTE5LjQ3Yy0zLjUtNS40Ny0xMC4xMy04LjA3LTE2LjQyLTYuNDNsLTMyLjEyLDguMzdjLTYuMjksMS42NC0xMC44LDcuMTQtMTEuMTksMTMuNjJsLTEuMzgsMjMuMDgtMzcuMjgsOS43MiwxMi41NC0xNjUuODksNDMuNjktMTEuMzgsNzcuODMsMTE3LjQzYzIuNjQsMy45OSw3LjAzLDYuNDgsMTEuODEsNi43LDQuNzYuMjIsOS4zOC0xLjg1LDEyLjM4LTUuNTgsMS40Mi0xLjc3LDIuOTUtMy40Nyw0LjU1LTUuMDcsNi43My02LjczLDE0Ljg0LTExLjk0LDI0LjEzLTE1LjUsOS4yLTMuNTMsMTkuNTYtNS4zMSwzMC44MS01LjMxczIxLjY0LDEuNzksMzAuOSw1LjMxYzMuMzMsMS4yNyw2LjU1LDIuNzcsOS41Nyw0LjQ2LDcuMSwzLjk4LDE2LjA4LDEuNTgsMjAuMjMtNS40Mkw0MDQuNDcsMzEuODdsNDQuMiw5LjIyLDIwLjY5LDE2NS4wNy0zNy43Mi03Ljg3WiIvPgogICAgICA8cGF0aCBkPSJNMjUuODksMzkyLjY5Yy0uMjEtLjU5LS43Ny0uOTgtMS40LS45OGgtNy4xM2MtLjYyLDAtMS4xOC4zOS0xLjQuOTdMLjA5LDQzNi4wM2MtLjE3LjQ2LS4xLjk2LjE4LDEuMzYuMjguNC43My42MywxLjIyLjYzaDUuMzVjLjYzLDAsMS4xOS0uNCwxLjQtLjk5bDMuNDQtOS42NmgxOC41MmwzLjQyLDkuNjVjLjIxLjU5Ljc3Ljk5LDEuNC45OWg1LjI5Yy40OSwwLC45NC0uMjQsMS4yMi0uNjMuMjgtLjQuMzQtLjkxLjE4LTEuMzZsLTE1LjgyLTQzLjM1Wk0yMC4zMiw0MDMuMTNsLjYzLTEuODgsNi43MiwxOWgtMTMuNDVsNi4xLTE3LjEzWiIvPgogICAgICA8cGF0aCBkPSJNODAuODYsMzkxLjcxaC00Ljg4Yy0uODIsMC0xLjQ5LjY3LTEuNDksMS40OXYyMS45NmwuMTYsMTAuMDktMjEuOTQtMzIuODhjLS4yOC0uNDEtLjc0LS42Ni0xLjI0LS42NmgtNi40OGMtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2NDMuMzVjMCwuODIuNjcsMS40OSwxLjQ5LDEuNDloNS4xMWMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTIyLjU2bC0uMTYtOS4zMywyMS45NCwzMi43MmMuMjguNDEuNzQuNjYsMS4yMy42Nmg2LjI0Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtNDMuMzVjMC0uODItLjY3LTEuNDktMS40OS0xLjQ5WiIvPgogICAgICA8cGF0aCBkPSJNMTY1LjQ3LDQzOC4wM2MuNjgsMCwxLjI4LS40NiwxLjQ0LTEuMTJsMTAuODgtNDMuMzVjLjExLS40NC4wMS0uOTItLjI3LTEuMjgtLjI4LS4zNi0uNzEtLjU3LTEuMTctLjU3aC01LjUzYy0uNjksMC0xLjI5LjQ3LTEuNDUsMS4xNGwtNi4yLDI1Ljk4LTEuMzgsNi44OC0xLjU1LTYuOTUtNi41NC0yNS45MmMtLjE3LS42Ni0uNzYtMS4xMi0xLjQ0LTEuMTJoLTYuNTRjLS42OCwwLTEuMjguNDYtMS40NCwxLjEybC02LjYxLDI2LjMyLTEuNDUsNi41OS0xLjM2LTYuNjItNi4zLTI2LjI4Yy0uMTYtLjY3LS43Ni0xLjE0LTEuNDUtMS4xNGgtNS41M2MtLjQ2LDAtLjg5LjIxLTEuMTcuNTctLjA4LjEtLjE0LjIyLS4xOS4zMy0uMjMtLjUzLS43NS0uOTEtMS4zNy0uOTFoLTMzLjI0Yy0uODIsMC0xLjQ5LjY3LTEuNDksMS40OXY0LjQ2YzAsLjgyLjY3LDEuNDksMS40OSwxLjQ5aDEyLjU1djM3LjRjMCwuODIuNjcsMS40OSwxLjQ5LDEuNDloNS4wNWMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTM3LjRoMTIuNjdjLjgyLDAsMS40OS0uNjcsMS40OS0xLjQ5di0zLjMybDEwLjY5LDQyLjU3Yy4xNy42Ni43NiwxLjEyLDEuNDQsMS4xMmg3LjEzYy42OCwwLDEuMjgtLjQ2LDEuNDQtMS4xMmw2LjEzLTI0LjM1LDEuODEtNy45MywxLjc4LDcuOTYsNi4xMiwyNC4zMmMuMTcuNjYuNzYsMS4xMiwxLjQ0LDEuMTJoNy4xM1oiLz4KICAgICAgPHBhdGggZD0iTTIxMS4wOCwzOTkuMTVjLjgyLDAsMS40OS0uNjcsMS40OS0xLjQ5di00LjQ2YzAtLjgyLS42Ny0xLjQ5LTEuNDktMS40OWgtMjkuNzljLS44MiwwLTEuNDkuNjctMS40OSwxLjQ5djQzLjM1YzAsLjgyLjY3LDEuNDksMS40OSwxLjQ5aDI5Ljg1Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtNC41MmMwLS44Mi0uNjctMS40OS0xLjQ5LTEuNDloLTIzLjMxdi0xMi42MWgyMC4zNGMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTQuMTZjMC0uODItLjY3LTEuNDktMS40OS0xLjQ5aC0yMC4zNHYtMTEuNjVoMjMuMjVaIi8+CiAgICAgIDxwYXRoIGQ9Ik0yNDkuMTgsNDEyLjM1YzEuNTEtMi4wOSwyLjI3LTQuNjYsMi4yNy03LjYyLDAtMS42Ni0uMjItMy4xOC0uNjctNC41NC0uNDUtMS4zNy0xLjEyLTIuNjEtMS45OC0zLjY4LS44Ny0xLjA3LTEuOTUtMS45OC0zLjIxLTIuNy0xLjIzLS43LTIuNjQtMS4yNC00LjE5LTEuNTktMS41MS0uMzQtMy4xOS0uNTEtNC45OS0uNTFoLTE5LjkyYy0uODIsMC0xLjQ5LjY3LTEuNDksMS40OXY0My4zNWMwLC44Mi42NywxLjQ5LDEuNDksMS40OWg1LjA1Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtMTYuOTVoMTIuNzJjMS45NiwwLDMuNDUuMjMsNC40NC42Ny44NS4zOCwxLjQxLjkxLDEuNzEsMS42Mi4zNy44Ni41NiwxLjk5LjU2LDMuMzZ2Ni41NGMwLDEuMTEuMDUsMi4wNS4xNiwyLjg3LjEyLjg5LjM0LDEuNzIuNjgsMi40OC4yNC41NC43Ny44OSwxLjM2Ljg5aDUuMTFjLjUsMCwuOTctLjI1LDEuMjQtLjY3LjI3LS40Mi4zMi0uOTQuMTItMS40LS4yOS0uNjgtLjQ2LTEuMzItLjUxLTEuOTEtLjA2LS43MS0uMDgtMS40MS0uMDgtMi4wOHYtNy42MWMwLTEuODQtLjI2LTMuNDYtLjc4LTQuODEtLjU2LTEuNDYtMS40Ny0yLjY1LTIuNzItMy41Ni0uMzQtLjI1LS43Mi0uNDctMS4xMi0uNjgsMS4zLS43OCwyLjM4LTEuNzcsMy4yNC0yLjk2Wk0yMjMuMDMsMzk5LjAzaDEyLjMxYzEuMjksMCwyLjQ3LjEzLDMuNDkuNC45NS4yNSwxLjc4LjY0LDIuNDcsMS4xNy42NS41LDEuMTQsMS4xMiwxLjQ3LDEuOTEuMzUuODIuNTMsMS44My41MywzLjAxLDAsMi4wOS0uNTgsMy43My0xLjc4LDUuMDMtMS4xNSwxLjI0LTMuMjMsMS44Ny02LjE5LDEuODdoLTEyLjMxdi0xMy4zOFoiLz4KICAgICAgPHBhdGggZD0iTTI2My4yMiw0MzYuNTV2LTE0Ljc1aDEwLjA1YzMuMywwLDYuMjMtLjYsOC43LTEuNzgsMi41My0xLjIxLDQuNTMtMi45Nyw1Ljk3LTUuMjQsMS40My0yLjI3LDIuMTYtNC45NywyLjE2LTguMDJzLS42OC01Ljc3LTIuMDItOC4wMmMtMS4zNi0yLjI3LTMuMzMtNC4wMy01Ljg3LTUuMjUtMi40Ny0xLjE4LTUuNDYtMS43OC04Ljg4LTEuNzhoLTE2LjY1Yy0uODIsMC0xLjQ5LjY3LTEuNDksMS40OXY0My4zNWMwLC44Mi42NywxLjQ5LDEuNDksMS40OWg1LjA1Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OVpNMjYzLjIyLDM5OS4xNWg5LjY5YzIuOTEsMCw1LjE3LjY4LDYuNzMsMi4wMiwxLjUxLDEuMywyLjI1LDMuMTcsMi4yNSw1LjcxLDAsMi4zOC0uNzIsNC4yMy0yLjE5LDUuNjUtMS40NywxLjQyLTMuNzUsMi4xNC02Ljc5LDIuMTRoLTkuNjl2LTE1LjUyWiIvPgogICAgICA8cGF0aCBkPSJNMzQxLjM4LDM5Ny43Yy0yLjAyLTIuMDgtNC40NS0zLjctNy4yMS00LjgtMi43NC0xLjEtNS44NS0xLjY1LTkuMjMtMS42NXMtNi41LjU2LTkuMjYsMS42NWMtMi43OCwxLjEtNS4yMSwyLjcxLTcuMjEsNC43OC0yLDIuMDYtMy41Niw0LjU5LTQuNjQsNy41MS0xLjA3LDIuODktMS42MSw2LjE2LTEuNjEsOS43M3MuNTMsNi43OCwxLjU4LDkuNjZjMS4wNiwyLjkyLDIuNjIsNS40Niw0LjY0LDcuNTQsMi4wMiwyLjA5LDQuNDYsMy43LDcuMjQsNC44MSwyLjc2LDEuMDksNS44OCwxLjY1LDkuMjYsMS42NXM2LjQ0LS41Niw5LjItMS42NWMyLjc4LTEuMSw1LjIxLTIuNzEsNy4yMS00Ljc4LDItMi4wNiwzLjU2LTQuNTksNC42NC03LjUxLDEuMDctMi44OSwxLjYxLTYuMTYsMS42MS05Ljczcy0uNTMtNi44My0xLjU4LTkuN2MtMS4wNi0yLjktMi42Mi01LjQzLTQuNjQtNy41MVpNMzM5LjM5LDQxNC45YzAsMy40LS42LDYuMzUtMS43OCw4Ljc3LTEuMTcsMi40LTIuNzksNC4yLTQuOTYsNS41LTIuMTUsMS4zLTQuNzQsMS45Ni03LjcsMS45Ni0yLjI1LDAtNC4yOS0uMzctNi4wNi0xLjExLTEuNzQtLjcyLTMuMjQtMS43Ny00LjQ2LTMuMTMtMS4yMy0xLjM3LTIuMi0zLjA4LTIuODgtNS4wOC0uNy0yLjAzLTEuMDUtNC4zNi0xLjA1LTYuOTIsMC0zLjQ0LjYtNi40MSwxLjc4LTguODMsMS4xNS0yLjM2LDIuODEtNC4yLDQuOTMtNS40NywyLjEzLTEuMjgsNC43NC0xLjkzLDcuNzQtMS45MywyLjI1LDAsNC4yNy4zNyw2LjAzLDEuMSwxLjc0LjczLDMuMjUsMS43OSw0LjUxLDMuMTQsMS4yNiwxLjM3LDIuMjMsMy4wNiwyLjg5LDUuMDMuNjgsMi4wMiwxLjAyLDQuMzYsMS4wMiw2Ljk2WiIvPgogICAgICA8cGF0aCBkPSJNMzg3Ljk3LDM5MS43MWgtNC44OGMtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2MjEuOTZsLjE2LDEwLjA5LTIxLjk0LTMyLjg4Yy0uMjgtLjQxLS43NC0uNjYtMS4yNC0uNjZoLTYuNDhjLS44MiwwLTEuNDkuNjctMS40OSwxLjQ5djQzLjM1YzAsLjgyLjY3LDEuNDksMS40OSwxLjQ5aDUuMTFjLjgyLDAsMS40OS0uNjcsMS40OS0xLjQ5di0yMi41NmwtLjE2LTkuMzMsMjEuOTQsMzIuNzJjLjI4LjQxLjc0LjY2LDEuMjMuNjZoNi4yNGMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTQzLjM1YzAtLjgyLS42Ny0xLjQ5LTEuNDktMS40OVoiLz4KICAgICAgPHBhdGggZD0iTTQyOC45MSwzOTIuNjljLS4yMS0uNTktLjc3LS45OC0xLjQtLjk4aC03LjEzYy0uNjIsMC0xLjE4LjM5LTEuNC45N2wtMTUuODgsNDMuMzVjLS4xNy40Ni0uMS45Ni4xOCwxLjM2LjI4LjQuNzMuNjMsMS4yMi42M2g1LjM1Yy42MywwLDEuMTktLjQsMS40LS45OWwzLjQ0LTkuNjZoMTguNTJsMy40Miw5LjY1Yy4yMS41OS43Ny45OSwxLjQuOTloNS4yOWMuNDksMCwuOTQtLjI0LDEuMjItLjYzLjI4LS40LjM0LS45MS4xOC0xLjM2bC0xNS44Mi00My4zNVpNNDIzLjMzLDQwMy4xM2wuNjMtMS44OCw2LjcyLDE5aC0xMy40NWw2LjEtMTcuMTNaIi8+CiAgICAgIDxyZWN0IHg9IjQ0Ni41NCIgeT0iMzkxLjcxIiB3aWR0aD0iOC4wMyIgaGVpZ2h0PSI0Ni4zMiIgcng9IjEuNDkiIHJ5PSIxLjQ5Ii8+CiAgICAgIDxwYXRoIGQ9Ik00OTMuOTcsNDEyLjM1YzEuNTEtMi4wOSwyLjI3LTQuNjYsMi4yNy03LjYyLDAtMS42NS0uMjItMy4xOC0uNjctNC41NC0uNDUtMS4zOC0xLjEyLTIuNjEtMS45OC0zLjY4LS44Ny0xLjA3LTEuOTUtMS45OC0zLjIxLTIuNzEtMS4yMy0uNy0yLjY0LTEuMjQtNC4xOS0xLjU5LTEuNTEtLjM0LTMuMTktLjUxLTQuOTktLjUxaC0xOS45MmMtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2NDMuMzVjMCwuODIuNjcsMS40OSwxLjQ5LDEuNDloNS4wNWMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTE2Ljk1aDEyLjcyYzEuOTYsMCwzLjQ1LjIzLDQuNDQuNjcuODUuMzgsMS40MS45MSwxLjcxLDEuNjEuMzcuODYuNTYsMS45OS41NiwzLjM2djYuNTRjMCwxLjA5LjA1LDIuMDYuMTYsMi44Ny4xMi44OS4zNCwxLjcyLjY4LDIuNDguMjQuNTQuNzcuODksMS4zNi44OWg1LjExYy41LDAsLjk3LS4yNSwxLjI0LS42Ny4yNy0uNDIuMzItLjk0LjEyLTEuNC0uMjktLjY4LS40Ni0xLjMyLS41MS0xLjkxLS4wNi0uNzEtLjA4LTEuNDEtLjA4LTIuMDh2LTcuNjFjMC0xLjg0LS4yNi0zLjQ2LS43OC00LjgxLS41Ni0xLjQ2LTEuNDctMi42NS0yLjcyLTMuNTYtLjM0LS4yNS0uNzItLjQ3LTEuMTItLjY4LDEuMy0uNzgsMi4zOC0xLjc3LDMuMjQtMi45NlpNNDY3LjgyLDM5OS4wM2gxMi4zMWMxLjI5LDAsMi40Ny4xMywzLjQ5LjQuOTUuMjUsMS43OC42NCwyLjQ3LDEuMTcuNjUuNSwxLjEzLDEuMTMsMS40NywxLjkxLjM1LjgyLjUzLDEuODMuNTMsMy4wMSwwLDIuMDktLjU4LDMuNzMtMS43OCw1LjAzLTEuMTUsMS4yNC0zLjIzLDEuODctNi4xOSwxLjg3aC0xMi4zMXYtMTMuMzhaIi8+CiAgICAgIDxwYXRoIGQ9Ik0xNTQuMTgsNDUxLjE3aC0yOS42N2MtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2NDMuMzVjMCwuODIuNjcsMS40OSwxLjQ5LDEuNDloNS4wNWMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTE3Ljc4aDIwLjc1Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtNC4yMmMwLS44Mi0uNjctMS40OS0xLjQ5LTEuNDloLTIwLjc1di0xMi40M2gyMy4xM2MuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTQuNDZjMC0uODItLjY3LTEuNDktMS40OS0xLjQ5WiIvPgogICAgICA8cGF0aCBkPSJNMTg4LjksNDkwaC0yMy4zMXYtMTIuNjFoMjAuMzNjLjgyLDAsMS40OS0uNjcsMS40OS0xLjQ5di00LjE2YzAtLjgyLS42Ny0xLjQ5LTEuNDktMS40OWgtMjAuMzN2LTExLjY1aDIzLjI1Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtNC40NmMwLS44Mi0uNjctMS40OS0xLjQ5LTEuNDloLTI5Ljc5Yy0uODIsMC0xLjQ5LjY3LTEuNDksMS40OXY0My4zNWMwLC44Mi42NywxLjQ5LDEuNDksMS40OWgyOS44NWMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTQuNTJjMC0uODItLjY3LTEuNDktMS40OS0xLjQ5WiIvPgogICAgICA8cGF0aCBkPSJNMjIwLjkzLDQ3My41NGMtMS41LS45OS0zLjI0LTEuNzctNS4xNi0yLjMzLTEuODQtLjUzLTMuNzgtLjk2LTUuNzUtMS4yOS0yLjk2LS41LTUuMzItMS4wNC03LjAzLTEuNjEtMS41LS41LTIuNTYtMS4xMi0zLjE1LTEuODUtLjU1LS42Ny0uODMtMS42OC0uODMtMi45OSwwLTEuMjMuMjktMi4yMy45LTMuMDQuNjItLjg0LDEuNTUtMS41MSwyLjc4LTIsMS4zLS41MiwyLjkzLS43OSw0LjgzLS43OXMzLjU1LjI4LDQuOTEuODRjMS4yOC41MywyLjI1LDEuMjksMi45NywyLjMyLjcxLDEuMDMsMS4xLDIuMzcsMS4xNywzLjk4LjAzLjguNjksMS40MiwxLjQ5LDEuNDJoNS4xN2MuNCwwLC43OC0uMTYsMS4wNi0uNDQuMjgtLjI4LjQzLS42Ny40My0xLjA3LS4wNC0yLjgxLS43NS01LjI5LTIuMTEtNy4zOS0xLjM2LTIuMDktMy4zMy0zLjc1LTUuODYtNC45MS0yLjQ3LTEuMTQtNS40OS0xLjcxLTguOTgtMS43MXMtNi40My41My04LjksMS41N2MtMi41NiwxLjA4LTQuNTUsMi42Ni01Ljk0LDQuNjktMS4zOSwyLjA1LTIuMSw0LjQ2LTIuMSw3LjE3LDAsMi4wNC4zNywzLjg0LDEuMSw1LjM1Ljc0LDEuNTMsMS44NSwyLjgzLDMuMywzLjg2LDEuMzcuOTgsMy4wOSwxLjgsNS4xMSwyLjQ0LDEuOTMuNjEsNC4xNywxLjE2LDYuNzIsMS42NiwyLjE0LjM0LDMuOTYuNzQsNS40MywxLjE3LDEuMzguNDEsMi41LjksMy4zMiwxLjQ1LjczLjQ4LDEuMjQsMS4wNiwxLjU2LDEuNzQuMzQuNzMuNTEsMS42OS41MSwyLjg1LDAsMS40NS0uMzUsMi41OC0xLjA3LDMuNDYtLjc2LjkzLTEuODEsMS42Mi0zLjIxLDIuMDgtMS41LjUtMy4zMy43Ni01LjQyLjc2LTIuNDIsMC00LjQtLjM1LTUuODgtMS4wNS0xLjQxLS42Ny0yLjQ0LTEuNTktMy4xNC0yLjg0LS43My0xLjI4LTEuMTEtMi44My0xLjE0LTQuNTktLjAyLS44MS0uNjgtMS40Ni0xLjQ5LTEuNDZoLTUuMjNjLS40LDAtLjc4LjE2LTEuMDYuNDQtLjI4LjI4LS40My42Ny0uNDMsMS4wNy4wNCwyLjk4Ljc1LDUuNjcsMi4xLDguMDEsMS4zOCwyLjM4LDMuNDYsNC4yNSw2LjIsNS41NiwyLjY3LDEuMjgsNi4wNCwxLjkzLDEwLjAxLDEuOTMsMy43NSwwLDYuOTgtLjU2LDkuNjEtMS42NiwyLjcxLTEuMTQsNC44MS0yLjc1LDYuMjMtNC44LDEuNDQtMi4wNywyLjE3LTQuNDksMi4xNy03LjIxcy0uNDctNC44OC0xLjM5LTYuNjJjLS45My0xLjc0LTIuMi0zLjE1LTMuOC00LjJaIi8+CiAgICAgIDxwYXRoIGQ9Ik0yNTkuMTgsNDUxLjE3aC0zMy4yNGMtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2NC40NmMwLC44Mi42NywxLjQ5LDEuNDksMS40OWgxMi41NXYzNy40YzAsLjgyLjY3LDEuNDksMS40OSwxLjQ5aDUuMDVjLjgyLDAsMS40OS0uNjcsMS40OS0xLjQ5di0zNy40aDEyLjY3Yy44MiwwLDEuNDktLjY3LDEuNDktMS40OXYtNC40NmMwLS44Mi0uNjctMS40OS0xLjQ5LTEuNDlaIi8+CiAgICAgIDxyZWN0IHg9IjI2Mi4zOSIgeT0iNDUxLjE3IiB3aWR0aD0iOC4wMyIgaGVpZ2h0PSI0Ni4zMiIgcng9IjEuNDkiIHJ5PSIxLjQ5Ii8+CiAgICAgIDxwYXRoIGQ9Ik0zMTQuMSw0NTEuODFjLS4yOC0uNC0uNzMtLjY0LTEuMjItLjY0aC01LjU5Yy0uNjMsMC0xLjIuNC0xLjQsMWwtOC42MiwyNC42Ni00LjAxLDExLjA2LTMuOTYtMTEuMDUtOC42Mi0yNC42N2MtLjIxLS42LS43Ny0xLTEuNC0xaC01LjY1Yy0uNDksMC0uOTQuMjQtMS4yMi42NHMtLjM0LjkxLS4xNywxLjM3bDE2LjIzLDQzLjM1Yy4yMi41OC43Ny45NiwxLjM5Ljk2aDYuNzhjLjYyLDAsMS4xNy0uMzgsMS4zOS0uOTZsMTYuMjMtNDMuMzVjLjE3LS40Ni4xMS0uOTctLjE3LTEuMzdaIi8+CiAgICAgIDxwYXRoIGQ9Ik0zMzEuNjMsNDUyLjE1Yy0uMjEtLjU5LS43Ny0uOTgtMS40LS45OGgtNy4xM2MtLjYyLDAtMS4xOC4zOS0xLjQuOTdsLTE1Ljg4LDQzLjM1Yy0uMTcuNDYtLjEuOTYuMTgsMS4zNi4yOC40LjczLjYzLDEuMjIuNjNoNS4zNWMuNjMsMCwxLjE5LS40LDEuNC0uOTlsMy40NC05LjY2aDE4LjUybDMuNDIsOS42NWMuMjEuNTkuNzcuOTksMS40Ljk5aDUuMjljLjQ5LDAsLjk0LS4yNCwxLjIyLS42My4yOC0uNC4zNC0uOTEuMTgtMS4zNmwtMTUuODItNDMuMzVaTTMyNi4wNiw0NjIuNTlsLjYzLTEuODgsNi43MiwxOWgtMTMuNDVsNi4xLTE3LjEzWiIvPgogICAgICA8cGF0aCBkPSJNMzc3LjE1LDQ4OS44OGgtMTkuODZ2LTM3LjIyYzAtLjgyLS42Ny0xLjQ5LTEuNDktMS40OWgtNS4wNWMtLjgyLDAtMS40OS42Ny0xLjQ5LDEuNDl2NDMuMzVjMCwuODIuNjcsMS40OSwxLjQ5LDEuNDloMjYuNGMuODIsMCwxLjQ5LS42NywxLjQ5LTEuNDl2LTQuNjRjMC0uODItLjY3LTEuNDktMS40OS0xLjQ5WiIvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+'
        
        let wordOscillation = {
            angle1: Math.random() * Math.PI * 2,
            angle2: Math.random() * Math.PI * 2,
            angle3: Math.random() * Math.PI * 2,
            speed: 0.02
        };

        let floatingImage = null;
        let backgroundColor = '#242AD6';
        let floatingImageOscillation = {
            x: 300,
            y: 300,
            targetX: 300,
            targetY: 300,
            velocityX: 0,
            velocityY: 0,
            smoothX: 0,
            smoothY: 0,
            lastUpdate: Date.now(),
            opacity: 0,
            scale: 0.3,
            lastTargetUpdate: 0,
            speed: 2.0
        };

        const Engine = Matter.Engine,
            Render = Matter.Render,
            World = Matter.World,
            Bodies = Matter.Bodies,
            Body = Matter.Body,
            Constraint = Matter.Constraint;

        let engine = Engine.create({
            gravity: {
                x: 0,
                y: 0  // Changed from -0.1 to 0 to match default inflate/deflate value
            },
            constraintIterations: 6,
            positionIterations: 12,
            velocityIterations: 12,
            enableSleeping: false,
            timing: {
                timeScale: 1,
                timestamp: 0,
                lastTime: 0,
                frameRequestId: 0
            }
        });

        let physicsObjects = new Map(); // Store letter-to-body mappings

        // Add these variables at the top
        let selectedWord = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // Add this at the top of your script after other constants
        const DUOTONE_SCHEMES = [
            { bg: "#7D9BA5", text: "#67FC04", stroke: "#ED82D4", outsidetxt: "#FFFFFF"}, // Current scheme
            { bg: "#3D2700", text: "#2255EF", stroke: "#F3B1CC", outsidetxt: "#FFFFFF"},
            { bg: "#C5C9CC", text: "#44192C", stroke: "#9366F7", outsidetxt: "#44192C"},
            { bg: "#FCC4DD", text: "#CDFE0E", stroke: "#E86E00", outsidetxt: "#E86E00"},
            { bg: "#CADBE3", text: "#FC3434", stroke: "#800C0C", outsidetxt: "#FC3434"},
        ];

        // Update the wall creation
        const walls = [
            Bodies.rectangle(canvas.width/2, -100, canvas.width * 3, 200, { 
                isStatic: true,
                render: { visible: false },
                friction: 0.1,
                restitution: 0.5
            }),
            Bodies.rectangle(canvas.width/2, canvas.height + 100, canvas.width * 3, 200, { 
                isStatic: true,
                render: { visible: false },
                friction: 0.1,
                restitution: 0.5
            }),
            Bodies.rectangle(-100, canvas.height/2, 200, canvas.height * 3, { 
                isStatic: true,
                render: { visible: false },
                friction: 0.1,
                restitution: 0.5
            }),
            Bodies.rectangle(canvas.width + 100, canvas.height/2, 200, canvas.height * 3, { 
                isStatic: true,
                render: { visible: false },
                friction: 0.1,
                restitution: 0.5
            })
        ];
        World.add(engine.world, walls);

        // Update the turbulence variables to have separate forces for each word
        let turbulence = {
            lastTime: 0,
            force: 0.2,
            changeInterval: 2000,
            words: [
                { // First word
                    currentForceX: 0,
                    currentForceY: 0,
                    targetForceX: 0,
                    targetForceY: 0,
                    phase: 0
                },
                { // Second word
                    currentForceX: 0,
                    currentForceY: 0,
                    targetForceX: 0,
                    targetForceY: 0,
                    phase: Math.PI * 2/3 // Offset by 120 degrees
                },
                { // Third word
                    currentForceX: 0,
                    currentForceY: 0,
                    targetForceX: 0,
                    targetForceY: 0,
                    phase: Math.PI * 4/3 // Offset by 240 degrees
                },
                { // Floating image
                    currentForceX: 0,
                    currentForceY: 0,
                    targetForceX: 0,
                    targetForceY: 0,
                    phase: Math.PI // Offset by 180 degrees
                }
            ]
        };

        // Add mouse state tracking variables at the top
        let isMouseDown = false;
        let canStartDrawing = false;

        // First, add these helper functions
        function addPathPoint(x, y, currentPath) {
            if (currentPath.length === 0) {
                currentPath.push({x, y});
                return true;
            }

            // Get last point
            const lastPoint = currentPath[currentPath.length - 1];
            
            // Calculate distance from last point
            const dx = x - lastPoint.x;
            const dy = y - lastPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Only add point if it's far enough from the last point (5 pixels minimum)
            if (distance > 5) {
                currentPath.push({x, y});
                return true;
            }
            return false;
        }

        // Update the mouse event handlers to properly handle both drawing and image dragging
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check if clicking on floating image first
            if (floatingImage && floatingImageOscillation.physicsBody) {
                const imgPos = floatingImageOscillation.physicsBody.position;
                const imgWidth = floatingImage.width * floatingImageOscillation.scale;
                const imgHeight = floatingImage.height * floatingImageOscillation.scale;
                
                if (mouseX >= imgPos.x - imgWidth/2 && mouseX <= imgPos.x + imgWidth/2 &&
                    mouseY >= imgPos.y - imgHeight/2 && mouseY <= imgPos.y + imgHeight/2) {
                    isDragging = true;
                    dragOffset = {
                        x: mouseX - imgPos.x,
                        y: mouseY - imgPos.y
                    };
                    return;
                }
            }

            // If not dragging image, start drawing path
            isMouseDown = true;
            if (currentDrawingSet === 1) {
                pathPoints = [{x: mouseX, y: mouseY}];
            } else if (currentDrawingSet === 2) {
                secondPathPoints = [{x: mouseX, y: mouseY}];
            } else {
                thirdPathPoints = [{x: mouseX, y: mouseY}];
            }
            isDrawingPath = true;
        });

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Handle image dragging
            if (isDragging && floatingImage && floatingImageOscillation.physicsBody) {
                Matter.Body.setPosition(floatingImageOscillation.physicsBody, {
                    x: mouseX - dragOffset.x,
                    y: mouseY - dragOffset.y
                });
                floatingImageOscillation.x = mouseX - dragOffset.x;
                floatingImageOscillation.y = mouseY - dragOffset.y;
                return;
            }

            // Handle path drawing
            if (isMouseDown && isDrawingPath) {
                let currentPath;
                if (currentDrawingSet === 1) {
                    currentPath = pathPoints;
                } else if (currentDrawingSet === 2) {
                    currentPath = secondPathPoints;
                } else {
                    currentPath = thirdPathPoints;
                }
                
                if (addPathPoint(mouseX, mouseY, currentPath)) {
                    drawSquare();
                    drawPath();
                }
            }
        });

        canvas.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                return;
            }

            if (isMouseDown && isDrawingPath) {
                isMouseDown = false;
                
                // Add letters for the current set
                let targetLetters;
                if (currentDrawingSet === 1) {
                    targetLetters = letters;
                } else if (currentDrawingSet === 2) {
                    targetLetters = secondLetters;
                } else {
                    targetLetters = thirdLetters;
                }

                for (let i = 0; i < targetLetters.length; i++) {
                    addLetter(currentDrawingSet === 2, currentDrawingSet === 3);
                }
                
                currentDrawingSet = currentDrawingSet === 3 ? 1 : currentDrawingSet + 1;
                isDrawingPath = false;
                
                if (!animationFrame) {
                    animate();
                }
            }
        });

        canvas.addEventListener('mouseleave', function() {
            isMouseDown = false;
            isDragging = false;
        });

        // Update the reset function to preserve current settings
        function reset() {
            isPaused = false;
            pauseButton.textContent = 'Pause Animation';
            pausedAnimationFrame = null;

            isMouseDown = false;
            canStartDrawing = false;
            isDrawingPath = false;
            isDragging = false;
            
            // Store floating image reference before clearing
            const existingFloatingImage = floatingImage;
            const existingFloatingImageOscillation = { ...floatingImageOscillation };
            
            // Clear physics world
            World.clear(engine.world);
            Engine.clear(engine);
            
            // Get current inflate value for gravity
            const inflateValue = -parseFloat(document.getElementById('inflateInput').value);
            
            // Recreate engine with current gravity
            engine = Engine.create({
                gravity: { x: 0, y: inflateValue },
                constraintIterations: 4,
                positionIterations: 8,
                velocityIterations: 8,
                enableSleeping: false
            });
            
            // Create new mouse and constraint
            const mouse = Matter.Mouse.create(canvas);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });
            
            // Add mouse constraint to world
            World.add(engine.world, mouseConstraint);
            
            // Clear arrays and reset state
            letterObjects.length = 0;
            secondLetterObjects.length = 0;
            thirdLetterObjects.length = 0;
            pathPoints = [];
            secondPathPoints = [];
            thirdPathPoints = [];
            
            // Reset drawing state
            hasDrawnPath = false;
            currentDrawingSet = 1;
            
            // Cancel existing animation frame
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Clear only the canvas area
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = document.getElementById('backgroundColorInput').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add walls back to world
            World.add(engine.world, walls);
            
            // Restore floating image if it existed
            if (existingFloatingImage) {
                floatingImage = existingFloatingImage;
                
                // Create new physics body for floating image
                const imageBody = Bodies.circle(
                    existingFloatingImageOscillation.x || canvas.width / 2,
                    existingFloatingImageOscillation.y || canvas.height / 2,
                    (floatingImage.width * existingFloatingImageOscillation.scale) / 2,
                    {
                        friction: 0.1,
                        restitution: 0.3,
                        density: 0.0001,
                        frictionAir: 0.1,
                        collisionFilter: {
                            category: 0x0008,  // Category for image
                            mask: 0xFFFFFF     // Collide with everything
                        }
                    }
                );
                
                // Restore floating image physics body
                floatingImageOscillation = {
                    ...existingFloatingImageOscillation,
                    physicsBody: imageBody
                };
                
                World.add(engine.world, imageBody);
            }
            
            // Set a small delay before enabling path drawing
            setTimeout(() => {
                isDrawingPath = true;
                canStartDrawing = true;
            }, 100);
            
            // Start fresh animation
            animate();
            
            // Update walls for current canvas size
            updatePhysicsWalls();
        }

        function drawSquare() {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, 600, 600);
            
            if (backgroundImage) {
                // Calculate dimensions to maintain aspect ratio and cover canvas
                const scale = Math.max(
                    canvas.width / backgroundImage.width,
                    canvas.height / backgroundImage.height
                );
                const width = backgroundImage.width * scale;
                const height = backgroundImage.height * scale;
                const x = (canvas.width - width) / 2;
                const y = (canvas.height - height) / 2;
                
                ctx.drawImage(backgroundImage, x, y, width, height);
            }

            // Draw SVG logo first, before any text
            
            if (logoSvg && logoSvg.complete && logoSvg.naturalWidth !== 0) {
                try {
                    const logoWidth = 100;
                    const padding = 25;
                    
                    // Get current color scheme index
                    const currentSchemeIndex = parseInt(document.getElementById('colorSchemeSelect').value) || 0;
                    // Get the outsidetxt color from the current scheme
                    const logoColor = DUOTONE_SCHEMES[currentSchemeIndex].outsidetxt;
                    
                    // Create a temporary canvas for color manipulation
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = logoWidth;
                    tempCanvas.height = logoWidth; // Use square dimensions if natural height is not available
                    
                    // Draw original SVG to temporary canvas
                    tempCtx.drawImage(
                        logoSvg,
                        0,
                        0,
                        tempCanvas.width,
                        tempCanvas.height
                    );
                    
                    // Get image data
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    
                    // Convert hex color to RGB
                    const hexToRgb = (hex) => {
                        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                    };
                    
                    const targetColor = hexToRgb(logoColor);
                    
                    
                    // Modify pixels
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] > 0) { // If pixel is not transparent
                            data[i] = targetColor.r;     // Red
                            data[i + 1] = targetColor.g; // Green
                            data[i + 2] = targetColor.b; // Blue
                            // Alpha channel (i + 3) remains unchanged
                        }
                    }
                    
                    // Put modified image data back
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // Draw the colored version to main canvas
                    ctx.drawImage(
                        tempCanvas,
                        padding,
                        canvas.height - logoWidth - padding,
                        logoWidth,
                        logoWidth
                    );
                    
                    
                    // Clean up
                    tempCanvas.remove();
                } catch (error) {
                    console.error('Error drawing SVG:', error, error.stack);
                }
            } else {
                console.log('SVG not ready:', {
                    exists: !!logoSvg,
                    complete: logoSvg ? logoSvg.complete : false,
                    naturalWidth: logoSvg ? logoSvg.naturalWidth : 0
                });
            }

            // Setup common text properties
            ctx.textRendering = 'geometricPrecision';
            ctx.font = '30px YourCustomFont1';
            ctx.textBaseline = 'top';
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            
            // Get current color scheme index
            const currentSchemeIndex = parseInt(document.getElementById('colorSchemeSelect').value) || 0;
            // Use the outsidetxt color from the current scheme
            const textColor = DUOTONE_SCHEMES[currentSchemeIndex].outsidetxt;
            const strokeColor = DUOTONE_SCHEMES[currentSchemeIndex].stroke;
            
            // Function to draw text with stroke
            function drawTextWithStroke(text, x, y) {
                // Draw the stroke
                ctx.strokeStyle = textColor;
                ctx.lineWidth = 1.5;
                ctx.lineJoin = 'round';
                ctx.strokeText(text, x, y);
                
                // Draw the text on top
                ctx.fillStyle = textColor;
                ctx.fillText(text, x, y);
            }
            
            // Draw left headers
            const headerText = document.getElementById('headerTextInput').value;
            ctx.textAlign = 'left';
            drawTextWithStroke(headerText, 20, 20);
            
            const headerText2 = document.getElementById('headerText2Input').value;
            drawTextWithStroke(headerText2, 20, 50);
            
            // Draw right headers
            const rightHeaderText = document.getElementById('rightHeaderTextInput').value;
            ctx.textAlign = 'right';
            drawTextWithStroke(rightHeaderText, canvas.width - 20, 20);
            
            const rightHeaderText2 = document.getElementById('rightHeaderText2Input').value;
            drawTextWithStroke(rightHeaderText2, canvas.width - 20, 50);
            
            // Draw footers
            ctx.textBaseline = 'bottom';
            const footer2Text = document.getElementById('footer2TextInput').value;
            drawTextWithStroke(footer2Text, canvas.width - 20, canvas.height - 50);
            
            const footerText = document.getElementById('footerTextInput').value;
            drawTextWithStroke(footerText, canvas.width - 20, canvas.height - 20);
        }

        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        function addLetter(isSecondSet = false, isThirdSet = false) {
            const targetLetters = isSecondSet ? secondLetterObjects : isThirdSet ? thirdLetterObjects : letterObjects;
            const lettersText = isSecondSet ? secondLetters : isThirdSet ? thirdLetters : letters;
            const currentPathPoints = isSecondSet ? secondPathPoints : isThirdSet ? thirdPathPoints : pathPoints;

            if (targetLetters.length >= lettersText.length || currentPathPoints.length < 2) return;
            
            try {
            let letter = lettersText[targetLetters.length];
                const baseSize = parseInt(letterSizeInput.value) || 60;
                const randomRange = parseInt(randomSizeInput.value) || 0;
            const size = baseSize + (Math.random() * randomRange * 2) - randomRange;

                // Calculate total path length with error checking
            const totalLength = currentPathPoints.reduce((total, point, i) => {
                if (i === 0) return 0;
                const dx = point.x - currentPathPoints[i-1].x;
                const dy = point.y - currentPathPoints[i-1].y;
                return total + Math.sqrt(dx * dx + dy * dy);
            }, 0);

                if (totalLength === 0) return; // Prevent division by zero

            const spacing = totalLength / (lettersText.length - 1);
            const targetDistance = targetLetters.length * spacing;
            let currentDistance = 0;
            let x = currentPathPoints[0].x;
            let y = currentPathPoints[0].y;
            
            for (let i = 1; i < currentPathPoints.length; i++) {
                const dx = currentPathPoints[i].x - currentPathPoints[i-1].x;
                const dy = currentPathPoints[i].y - currentPathPoints[i-1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                
                if (currentDistance + segmentLength >= targetDistance) {
                    const ratio = (targetDistance - currentDistance) / segmentLength;
                    x = currentPathPoints[i-1].x + dx * ratio;
                    y = currentPathPoints[i-1].y + dy * ratio;
                    break;
                }
                currentDistance += segmentLength;
            }

                const speedMultiplier = parseFloat(document.getElementById('oscillationSpeedInput').value) || 1;
            
            let newLetter = {
                letter: letter,
                x: x,
                y: y,
                targetX: x,
                targetY: y,
                vx: 0,
                vy: 0,
                size: size,
                maxSize: size,
                growth: 1,
                progress: 1,
                    trianglePoints: [], // Initialize empty array for triangle points
                oscillation: {
                    angle: Math.random() * Math.PI * 2,
                    speed: (0.02 + Math.random() * 0.02) * speedMultiplier,
                    radius: 4 + Math.random() * 4,
                    phase: 1,
                    smoothX: 0,
                    smoothY: 0,
                    velocityX: 0,
                    velocityY: 0,
                    secondaryAngle: Math.random() * Math.PI * 2,
                    secondarySpeed: (0.01 + Math.random() * 0.01) * speedMultiplier,
                    currentRadius: 0,
                    targetRadius: 4 + Math.random() * 4
                    },
                    physicsBody: null,
                    outlinePoints: [], // Add this new property
                };

                // Generate the outline points once when creating the letter
                newLetter.outlinePoints = generateLetterOutline(newLetter);

                // Create circular physics body for the letter
                const radius = newLetter.size / 2;
                const body = Bodies.circle(x, y, radius, {
                    friction: 0.1,
                    restitution: 0.3,
                    density: 0.0001,
                    frictionAir: 0.1,
                    collisionFilter: {
                        group: -currentDrawingSet,
                        category: Math.pow(2, currentDrawingSet),
                        mask: 0xFFFFFF ^ Math.pow(2, currentDrawingSet)
                    },
                    render: {
                        visible: false
                    },
                    slop: 0
                });

                // Get the previous letter in the same word
                const letterSet = targetLetters;
                const prevLetter = letterSet[letterSet.length - 1];

                // Only create constraint if there's a previous letter
                if (prevLetter && prevLetter.physicsBody) {
                    const constraint = Constraint.create({
                        bodyA: prevLetter.physicsBody,
                        bodyB: body,
                        stiffness: 0.001,    // Very loose connection
                        damping: 0.1,        // Low damping for more natural movement
                        length: radius * 2,   // More space between letters
                        render: {
                            visible: false
                        }
                    });
                    World.add(engine.world, constraint);
                }

                // Add body to world regardless of constraint
                World.add(engine.world, body);
                newLetter.physicsBody = body;
                physicsObjects.set(body.id, newLetter);

                // Generate and store triangle points
                const letterPoints = getLetterPixels(newLetter);
                const numTriangles = triangleSettings.density * 3;
                
                // When generating points, use the same rotation for all shapes
                const baseRotation = shapeSettings.rotation * Math.PI / 180;
                
                for (let i = 0; i < numTriangles; i++) {
                    if (letterPoints.length > 0) {
                        const point = letterPoints[Math.floor(Math.random() * letterPoints.length)];
                        const jitter = shapeSettings.size * 0.2;
                        const offset = {
                            x: point.x + (Math.random() - 0.5) * jitter,
                            y: point.y + (Math.random() - 0.5) * jitter,
                            rotation: baseRotation, // Use same rotation for all shapes
                            shape: shapeSettings.shapes[Math.floor(Math.random() * shapeSettings.shapes.length)]
                        };
                        newLetter.trianglePoints.push(offset);
                    }
                }

            targetLetters.push(newLetter);
            } catch (error) {
                console.error('Error in addLetter:', error);
                reset();
            }
        }

        // Add this new function to generate the outline points
        function generateLetterOutline(letter) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = letter.size * 2;
            tempCanvas.height = letter.size * 2;
            
            // Draw the letter on temp canvas
            tempCtx.font = `${letter.size}px ${currentFont}`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(letter.letter, tempCanvas.width/2, tempCanvas.height/2);
            
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const pixels = imageData.data;
            const outlinePoints = [];
            
            // Random seed for this letter's waves
            const seed = Math.random() * 1000;
            
            // Get waviness value from slider
            const waviness = parseFloat(document.getElementById('outerStrokeWavinessInput').value);
            
            // Increase minimum sampling rate and make it more responsive to waviness
            const samplingRate = Math.max(2, Math.ceil(waviness * 3));
            
            // First pass: collect edge pixels
            const edgePixels = [];
            for(let y = 0; y < tempCanvas.height; y++) {
                for(let x = 0; x < tempCanvas.width; x++) {
                    const idx = (y * tempCanvas.width + x) * 4;
                    if(pixels[idx + 3] > 0) {
                        if(x === 0 || x === tempCanvas.width - 1 || 
                           y === 0 || y === tempCanvas.height - 1 ||
                           pixels[((y-1) * tempCanvas.width + x) * 4 + 3] === 0 ||
                           pixels[((y+1) * tempCanvas.width + x) * 4 + 3] === 0 ||
                           pixels[(y * tempCanvas.width + x - 1) * 4 + 3] === 0 ||
                           pixels[(y * tempCanvas.width + x + 1) * 4 + 3] === 0) {
                            edgePixels.push({x, y});
                        }
                    }
                }
            }
            
            // Sort edge pixels by angle for continuous outline
            const center = {
                x: tempCanvas.width / 2,
                y: tempCanvas.height / 2
            };
            
            edgePixels.sort((a, b) => {
                const angleA = Math.atan2(a.y - center.y, a.x - center.x);
                const angleB = Math.atan2(b.y - center.y, b.x - center.x);
                return angleA - angleB;
            });
            
            // Second pass: generate outline points with enhanced interpolation
            const interpolationSteps = Math.max(4, Math.ceil(waviness * 2));
            for(let i = 0; i < edgePixels.length; i += samplingRate) {
                const pixel = edgePixels[i];
                const angle = Math.atan2(pixel.y - center.y, pixel.x - center.x);
                
                // Base offset with smooth transition
                let offset = letter.size * 0.1;
                const waveFreq = 4;
                const waveDepth = 1;
                
                // Add more intermediate points for smoother outline
                for(let j = 0; j < interpolationSteps; j++) {
                    const t = j / interpolationSteps;
                    const interpolatedAngle = angle + (t * 2 * Math.PI / edgePixels.length);
                    const waveOffset = Math.sin(interpolatedAngle * waveFreq + seed) * waveDepth * letter.size * waviness;
                    const totalOffset = offset + waveOffset;
                    
                    outlinePoints.push({
                        relX: (pixel.x - center.x) + Math.cos(interpolatedAngle) * totalOffset,
                        relY: (pixel.y - center.y) + Math.sin(interpolatedAngle) * totalOffset
                    });
                }
            }
            
            // Ensure the outline is closed
            if(outlinePoints.length > 0) {
                // Add extra points to smooth the connection
                const first = outlinePoints[0];
                const last = outlinePoints[outlinePoints.length - 1];
                
                // Add interpolated points between last and first point
                for(let i = 1; i <= 3; i++) {
                    const t = i / 4;
                    outlinePoints.push({
                        relX: last.relX + (first.relX - last.relX) * t,
                        relY: last.relY + (first.relY - last.relY) * t
                    });
                }
                outlinePoints.push({...first});
            }
            
            // Smoothing pass to reduce any remaining gaps
            const smoothedPoints = [];
            const smoothingWindow = 3;
            
            for(let i = 0; i < outlinePoints.length; i++) {
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                
                for(let j = -smoothingWindow; j <= smoothingWindow; j++) {
                    const idx = (i + j + outlinePoints.length) % outlinePoints.length;
                    sumX += outlinePoints[idx].relX;
                    sumY += outlinePoints[idx].relY;
                    count++;
                }
                
                smoothedPoints.push({
                    relX: sumX / count,
                    relY: sumY / count
                });
            }
            
            tempCanvas.remove();
            return smoothedPoints;
        }

        function drawPath() {
            // Draw first path
            if (pathPoints.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = currentDrawingSet === 1 && isDrawingPath ? '#666666' : 'rgba(204, 204, 204, 0)';
                ctx.lineWidth = 2;
                for (let i = 0; i < pathPoints.length; i++) {
                    if (i === 0) ctx.moveTo(pathPoints[i].x, pathPoints[i].y);
                    else ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                }
                ctx.stroke();
            }

            // Draw second path
            if (secondPathPoints.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = currentDrawingSet === 2 && isDrawingPath ? '#666666' : 'rgba(204, 204, 204, 0)';
                ctx.lineWidth = 2;
                for (let i = 0; i < secondPathPoints.length; i++) {
                    if (i === 0) ctx.moveTo(secondPathPoints[i].x, secondPathPoints[i].y);
                    else ctx.lineTo(secondPathPoints[i].x, secondPathPoints[i].y);
                }
                ctx.stroke();
            }

            // Draw third path
            if (thirdPathPoints.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = currentDrawingSet === 3 && isDrawingPath ? '#666666' : 'rgba(204, 204, 204, 0)';
                ctx.lineWidth = 2;
                for (let i = 0; i < thirdPathPoints.length; i++) {
                    if (i === 0) ctx.moveTo(thirdPathPoints[i].x, thirdPathPoints[i].y);
                    else ctx.lineTo(thirdPathPoints[i].x, thirdPathPoints[i].y);
                }
                ctx.stroke();
            }
        }

        function arrangeLetters() {
            if (pathPoints.length < 2) return;
            
            const totalLength = pathPoints.reduce((total, point, i) => {
                if (i === 0) return 0;
                const dx = point.x - pathPoints[i-1].x;
                const dy = point.y - pathPoints[i-1].y;
                return total + Math.sqrt(dx * dx + dy * dy);
            }, 0);

            const spacing = totalLength / (letterObjects.length - 1);
            
            letterObjects.forEach((letter, index) => {
                let targetDistance = index * spacing;
                let currentDistance = 0;
                
                for (let i = 1; i < pathPoints.length; i++) {
                    const dx = pathPoints[i].x - pathPoints[i-1].x;
                    const dy = pathPoints[i].y - pathPoints[i-1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    
                    if (currentDistance + segmentLength >= targetDistance) {
                        const ratio = (targetDistance - currentDistance) / segmentLength;
                        letter.targetX = pathPoints[i-1].x + dx * ratio;
                        letter.targetY = pathPoints[i-1].y + dy * ratio;
                        break;
                    }
                    
                    currentDistance += segmentLength;
                }
                
                letter.progress = 0;
            });
            
            arranging = true;
        }

        function updateFloatingImage() {
            if (!floatingImage) return;
            
            const now = Date.now();
            const deltaTime = (now - floatingImageOscillation.lastUpdate) / 1000;
            floatingImageOscillation.lastUpdate = now;
            
            // Gentle fade-in
            if (floatingImageOscillation.opacity < 1) {
                floatingImageOscillation.opacity += deltaTime * 1.5;
                if (floatingImageOscillation.opacity > 1) floatingImageOscillation.opacity = 1;
            }
            
            floatingImageOscillation.scale = parseFloat(document.getElementById('floatingImageSizeInput').value);
            const speedMultiplier = floatingImageOscillation.speed;
            
            // Adjust target update frequency based on new speed range
            if (now - floatingImageOscillation.lastTargetUpdate > 5000 / (speedMultiplier / 2)) {
                const overflow = 150;
                floatingImageOscillation.targetX = -overflow + Math.random() * (canvas.width + overflow * 2);
                floatingImageOscillation.targetY = -overflow + Math.random() * (canvas.height + overflow * 2);
                floatingImageOscillation.lastTargetUpdate = now;
            }
            
            // Adjusted spring physics for the new speed range
            const springStrength = 0.2;
            const damping = 0.985;
            const baseSpeed = 0.75 * (speedMultiplier / 2); // Adjusted for new minimum speed
            
            const dx = floatingImageOscillation.targetX - floatingImageOscillation.x;
            const dy = floatingImageOscillation.targetY - floatingImageOscillation.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0.1) {
                const normalizedDx = dx / distance;
                const normalizedDy = dy / distance;
                
                floatingImageOscillation.velocityX += normalizedDx * baseSpeed * springStrength * deltaTime;
                floatingImageOscillation.velocityY += normalizedDy * baseSpeed * springStrength * deltaTime;
            }
            
            floatingImageOscillation.velocityX *= damping;
            floatingImageOscillation.velocityY *= damping;
            
            // Adjust max speed for new range
            const maxSpeed = 4 * (speedMultiplier / 2);
            const currentSpeed = Math.sqrt(
                floatingImageOscillation.velocityX * floatingImageOscillation.velocityX + 
                floatingImageOscillation.velocityY * floatingImageOscillation.velocityY
            );
            
            if (currentSpeed > maxSpeed) {
                const speedFactor = maxSpeed / currentSpeed;
                floatingImageOscillation.velocityX *= speedFactor;
                floatingImageOscillation.velocityY *= speedFactor;
            }
            
            floatingImageOscillation.x += floatingImageOscillation.velocityX;
            floatingImageOscillation.y += floatingImageOscillation.velocityY;
            
            // Adjust organic movement for new speed range
            const time = now * 0.001 * (speedMultiplier / 2);
            const organicAmplitude = 2.5 * (speedMultiplier / 2);
            floatingImageOscillation.smoothX = Math.sin(time * 0.7) * organicAmplitude;
            floatingImageOscillation.smoothY = Math.cos(time * 0.5) * organicAmplitude;
        }

        function updatePositions() {
            Engine.update(engine);
            updateTurbulence(); // Add this line to apply turbulence forces

            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet) => {
                letterSet.forEach(letter => {
                    if (letter.physicsBody) {
                        const pos = letter.physicsBody.position;
                        const margin = letter.size / 2;
                        const bounce = 0.5;

                        // Strict boundary enforcement with bounce
                        if (pos.x < margin) {
                            Body.setPosition(letter.physicsBody, { 
                                x: margin + 1, // Add small offset to prevent sticking
                                y: pos.y 
                            });
                            Body.setVelocity(letter.physicsBody, { 
                                x: Math.abs(letter.physicsBody.velocity.x) * bounce, 
                                y: letter.physicsBody.velocity.y 
                            });
                        }
                        if (pos.x > canvas.width - margin) {
                            Body.setPosition(letter.physicsBody, { 
                                x: canvas.width - margin - 1,
                                y: pos.y 
                            });
                            Body.setVelocity(letter.physicsBody, { 
                                x: -Math.abs(letter.physicsBody.velocity.x) * bounce, 
                                y: letter.physicsBody.velocity.y 
                            });
                        }
                        if (pos.y < margin) {
                            Body.setPosition(letter.physicsBody, { 
                                x: pos.x, 
                                y: margin + 1
                            });
                            Body.setVelocity(letter.physicsBody, { 
                                x: letter.physicsBody.velocity.x, 
                                y: Math.abs(letter.physicsBody.velocity.y) * bounce 
                            });
                        }
                        if (pos.y > canvas.height - margin) {
                            Body.setPosition(letter.physicsBody, { 
                                x: pos.x, 
                                y: canvas.height - margin - 1
                            });
                            Body.setVelocity(letter.physicsBody, { 
                                x: letter.physicsBody.velocity.x, 
                                y: -Math.abs(letter.physicsBody.velocity.y) * bounce 
                            });
                        }

                        letter.x = pos.x;
                        letter.y = pos.y;
                    }
                });
            });
        }

        function getClosestPointOnPath(pos, pathPoints) {
            let closestPoint = pathPoints[0];
            let minDistance = Number.MAX_VALUE;

            for (let i = 0; i < pathPoints.length - 1; i++) {
                const p1 = pathPoints[i];
                const p2 = pathPoints[i + 1];
                const point = getClosestPointOnSegment(pos, p1, p2);
                const distance = getDistance(pos, point);

                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = point;
                }
            }

            return closestPoint;
        }

        function getClosestPointOnSegment(p, v1, v2) {
            const dx = v2.x - v1.x;
            const dy = v2.y - v1.y;
            const lengthSquared = dx * dx + dy * dy;

            if (lengthSquared === 0) return v1;

            let t = ((p.x - v1.x) * dx + (p.y - v1.y) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));

            return {
                x: v1.x + t * dx,
                y: v1.y + t * dy
            };
        }

        function getDistance(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Add this function to draw the background
        function drawBackground() {
            // Draw a solid rectangle covering the entire canvas
            ctx.save();
            ctx.fillStyle = document.getElementById('backgroundColorInput').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
    

        // Update drawLetters function to draw floating image first
        function drawLetters() {
            
            
            
            ctx.fillStyle = document.getElementById('backgroundColorInput').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawSquare();
            drawPath();
            
            
            // Draw floating image
            if (floatingImage && floatingImageOscillation.physicsBody) {
                const pos = floatingImageOscillation.physicsBody.position;
                const width = floatingImage.width * floatingImageOscillation.scale;
                const height = floatingImage.height * floatingImageOscillation.scale;
                
                try {
                    ctx.save();
                    ctx.globalAlpha = floatingImageOscillation.opacity;
                    ctx.drawImage(
                        floatingImage,
                        pos.x - width/2,
                        pos.y - height/2,
                        width,
                        height
                    );
                    ctx.restore();
                } catch (error) {
                    console.error('Error drawing floating image:', error);
                }
            }
            
            // First pass: Draw all triangles (shapes)
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet, setIndex) => {
                letterSet.forEach(letter => {
                    drawLetterTriangles(letter);
                });
            });
            
            // Second pass: Draw all letter outlines
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet, setIndex) => {
                letterSet.forEach(letter => {
                    drawLetterOutline(letter);
                });
            });
            
            // Third pass: Draw all letters on top
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet, setIndex) => {
                letterSet.forEach(letter => {
                    drawLetterText(letter);
                });
            });

        }
    
        // Update the animation loop for better movement
        function animate() {
            if (!isPaused) {
                try {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = document.getElementById('backgroundColorInput').value;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const turbulenceForce = parseFloat(document.getElementById('turbulenceInput').value);
                    const time = Date.now() / 1000;
                    
                    // Apply forces to letters
                    [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet, setIndex) => {
                        letterSet.forEach((letter, index) => {
                            if (letter && letter.physicsBody) {
                                const xForce = Math.sin(time * 0.5 + index * 0.5) * 0.0001 * turbulenceForce;
                                const yForce = Math.cos(time * 0.3 + index * 0.5) * 0.0001 * turbulenceForce;
                                
                                Body.applyForce(letter.physicsBody, 
                                    letter.physicsBody.position, 
                                    { x: xForce, y: yForce }
                                );
                                
                                letter.x = letter.physicsBody.position.x;
                                letter.y = letter.physicsBody.position.y;
                            }
                        });
                    });
                    
                    Engine.update(engine);
                    
                    updateLetterSizes(letterObjects);
                    updateLetterSizes(secondLetterObjects);
                    updateLetterSizes(thirdLetterObjects);
                    
                    drawLetters();
                    
                    animationFrame = requestAnimationFrame(animate);
                } catch (error) {
                    // Try to recover animation
                    animationFrame = requestAnimationFrame(animate);
                }
            }
        }

        // Update the size gradient function to properly handle physics bodies
        function updateLetterSizes(letterSet) {
            const oscillationAmount = parseInt(document.getElementById('sizeOscillationInput').value);
            
            letterSet.forEach((letter, index) => {
                if (letter) {
                    // Calculate size based on position in word
                    const progress = index / (letterSet.length - 1); // 0 to 1
                    const sizeChange = oscillationAmount * progress; // Gradually increase size
                    const newSize = letter.maxSize + sizeChange;
                    
                    // Only update if size has changed
                    if (letter.size !== newSize) {
                        letter.size = newSize;
                        
                        // Update physics body size if it exists
                        if (letter.physicsBody) {
                            const currentRadius = letter.physicsBody.circleRadius;
                            const newRadius = letter.size / 2;
                            const scale = newRadius / currentRadius;
                            
                            // Scale the body while maintaining its position and properties
                            Matter.Body.scale(letter.physicsBody, scale, scale);
                        }
                    }
                }
            });
        }

        // Add these functions to handle color input synchronization
        function setupColorInputs(pickerID, inputID) {
            const picker = document.getElementById(pickerID);
            const input = document.getElementById(inputID);

            picker.addEventListener('input', function(e) {
                input.value = e.target.value.toUpperCase();
                input.style.setProperty('--input-color', e.target.value);
                
                // Update backgroundColor if this is the background color input
                if (pickerID === 'backgroundColorPicker') {
                    backgroundColor = e.target.value;
                }
                
                if (!animationFrame) {
                    drawSquare();
                }
            });

            input.addEventListener('input', function(e) {
                let color = e.target.value;
            if (!color.startsWith('#')) {
                color = '#' + color;
            }
            if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    picker.value = color;
                    this.style.setProperty('--input-color', color);
                    
                    // Update backgroundColor if this is the background color input
                    if (pickerID === 'backgroundColorPicker') {
                        backgroundColor = color;
                    }
                    
                    if (!animationFrame) {
                        drawSquare();
                    }
                }
            });
        }

        // Initialize color input pairs
        setupColorInputs('backgroundColorPicker', 'backgroundColorInput');
        setupColorInputs('letterColorPicker', 'letterColorInput');

        // Add image upload handler
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        backgroundImage = img;
                        drawSquare(); // Redraw canvas with new background
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Add remove image handler
        document.getElementById('removeImageBtn').addEventListener('click', function() {
            backgroundImage = null;
            drawSquare(); // Redraw canvas without background
        });

        // Add event listener for header text changes
        document.getElementById('headerTextInput').addEventListener('input', function() {
            if (!animationFrame) {
                drawSquare();
            }
        });

        // Add event listener for footer text changes
        document.getElementById('footerTextInput').addEventListener('input', function() {
            if (!animationFrame) {
                drawSquare();
            }
        });

        // Update the letter size input event listener to affect all three sets
        letterSizeInput.addEventListener('input', function() {
            document.getElementById('letterSizeValue').textContent = this.value;
            const newSize = parseInt(this.value);
            const randomRange = parseInt(randomSizeInput.value);
            
            // Update all existing letters in all three sets
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    const newRandomSize = newSize + (Math.random() * randomRange * 2) - randomRange;
                    letter.size = newRandomSize;
                    letter.maxSize = newRandomSize;
                });
            });
        });

        // Update the random size input event listener to affect all three sets
        randomSizeInput.addEventListener('input', function() {
            const randomRange = parseInt(this.value);
            document.getElementById('randomSizeValue').textContent = randomRange;
            const baseSize = parseInt(letterSizeInput.value);
            
            // Update all existing letters in all three sets with new random sizes
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    const newSize = baseSize + (Math.random() * randomRange * 2) - randomRange;
                    letter.size = newSize;
                    letter.maxSize = newSize;
                });
            });
        });

        // Add floating image upload handler
        document.getElementById('floatingImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        floatingImage = img;
                        
                        // Create physics body for floating image
                        const imageBody = Bodies.circle(
                            canvas.width / 2,
                            canvas.height / 2,
                            (img.width * floatingImageOscillation.scale) / 2,
                            {
                                friction: 0.1,
                                restitution: 0.3,
                                density: 0.0001,
                                frictionAir: 0.1,
                                collisionFilter: {
                                    category: 0x0008,  // New category for image
                                    mask: 0xFFFFFF     // Collide with everything
                                }
                            }
                        );
                        
                        floatingImageOscillation.physicsBody = imageBody;
                        World.add(engine.world, imageBody);
                        
                        // Initialize other properties
                        floatingImageOscillation.x = canvas.width / 2;
                        floatingImageOscillation.y = canvas.height / 2;
                        floatingImageOscillation.opacity = 1;
                        floatingImageOscillation.scale = parseFloat(document.getElementById('floatingImageSizeInput').value);
                        
                        if (!animationFrame) {
                            animate();
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('removeFloatingImageBtn').addEventListener('click', function() {
            floatingImage = null;
            floatingImageOscillation.opacity = 0;
            floatingImageOscillation.scale = parseFloat(document.getElementById('floatingImageSizeInput').value);
        });

        // Add event listener for the size slider
        document.getElementById('floatingImageSizeInput').addEventListener('input', function() {
            const newScale = parseFloat(this.value);
            document.getElementById('floatingImageSizeValue').textContent = newScale.toFixed(2);
            floatingImageOscillation.scale = newScale;
        });

        // Replace the old PNG export function with our new JPG export
        function exportToJPG() {
            // Create a temporary canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 1. Draw solid background color
            tempCtx.fillStyle = document.getElementById('backgroundColorInput').value;
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // 2. Draw our canvas content on top
            tempCtx.drawImage(canvas, 0, 0);
            
            // 3. Draw the SVG logo if it exists
            if (logoSvg.complete) {
                const logoWidth = 50;
                const padding = 10;
                try {
                    tempCtx.drawImage(
                        logoSvg,
                        padding,
                        tempCanvas.height - logoWidth - padding,
                        logoWidth,
                        logoWidth * (logoSvg.height / logoSvg.width)
                    );
                } catch (error) {
                    console.error('Error drawing SVG:', error);
                }
            }
            
            try {
                const link = document.createElement('a');
                link.download = 'export.jpg';
                link.href = tempCanvas.toDataURL('image/jpeg', 1.0);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error during export:', error);
            }
        }

        // Make sure the button has the right text and event listener
        window.onload = function() {
            const exportBtn = document.getElementById('exportButton');
            if (exportBtn) {
                exportBtn.textContent = 'Export JPG';
                exportBtn.addEventListener('click', exportToJPG);
            }
        };

        // Add mouse interaction
        const mouse = Matter.Mouse.create(canvas);
        const mouseConstraint = Matter.MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });

        World.add(engine.world, mouseConstraint);

        // Update mouse interaction for dragging words and image
        canvas.addEventListener('mousedown', function(e) {
            if (isDrawingPath) return; // Don't interfere with path drawing

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check if clicking on floating image
            if (floatingImage && floatingImageOscillation.physicsBody) {
                const imgPos = floatingImageOscillation.physicsBody.position;
                const imgWidth = floatingImage.width * floatingImageOscillation.scale;
                const imgHeight = floatingImage.height * floatingImageOscillation.scale;
                
                // Check if mouse is within image bounds
                if (mouseX >= imgPos.x - imgWidth/2 && mouseX <= imgPos.x + imgWidth/2 &&
                    mouseY >= imgPos.y - imgHeight/2 && mouseY <= imgPos.y + imgHeight/2) {
                    isDragging = true;
                    dragOffset = {
                        x: mouseX - imgPos.x,
                        y: mouseY - imgPos.y
                    };
                }
            }
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDragging && floatingImage && floatingImageOscillation.physicsBody) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

                // Update physics body position
                Matter.Body.setPosition(floatingImageOscillation.physicsBody, {
                    x: mouseX - dragOffset.x,
                    y: mouseY - dragOffset.y
                });
                
                // Update oscillation position
                floatingImageOscillation.x = mouseX - dragOffset.x;
                floatingImageOscillation.y = mouseY - dragOffset.y;
            }
        });

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
        });

        // Helper function to get word bounds
        function getWordBounds(letterSet) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            letterSet.forEach(letter => {
                if (letter.physicsBody) {
                    const pos = letter.physicsBody.position;
                    minX = Math.min(minX, pos.x - letter.size/2);
                    maxX = Math.max(maxX, pos.x + letter.size/2);
                    minY = Math.min(minY, pos.y - letter.size/2);
                    maxY = Math.max(maxY, pos.y + letter.size/2);
                }
            });
            
            return {
                min: { x: minX, y: minY },
                max: { x: maxX, y: maxY },
                center: {
                    x: (minX + maxX) / 2,
                    y: (minY + maxY) / 2
                }
            };
        }

        // Add these event listeners
        document.getElementById('springStiffnessInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('springStiffnessValue').textContent = value;
            updatePhysicsProperties();
        });

        document.getElementById('springDampingInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('springDampingValue').textContent = value;
            updatePhysicsProperties();
        });

        document.getElementById('bouncinessInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('bouncinessValue').textContent = value;
            updatePhysicsProperties();
        });

        document.getElementById('airFrictionInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('airFrictionValue').textContent = value;
            updatePhysicsProperties();
        });

        // Add this function to update physics properties
        function updatePhysicsProperties() {
            const stiffness = parseFloat(document.getElementById('springStiffnessInput').value);
            const damping = parseFloat(document.getElementById('springDampingInput').value);
            const bounciness = parseFloat(document.getElementById('bouncinessInput').value);
            const airFriction = parseFloat(document.getElementById('airFrictionInput').value);

            // Update all constraints
            engine.world.constraints.forEach(constraint => {
                if (constraint.stiffness !== undefined) {
                    constraint.stiffness = stiffness;
                    constraint.damping = damping;
                }
            });

            // Update all bodies
            engine.world.bodies.forEach(body => {
                if (!body.isStatic) {
                    body.restitution = bounciness;
                    body.frictionAir = airFriction;
                }
            });
        }

        // Add this function for the color scheme generator
        function applyColorScheme(index) {
            const scheme = DUOTONE_SCHEMES[index];
            
            // Update background color
            backgroundColor = scheme.bg;
            document.getElementById('backgroundColorPicker').value = scheme.bg;
            document.getElementById('backgroundColorInput').value = scheme.bg;
            
            // Update letter color
            document.getElementById('letterColorPicker').value = scheme.text;
            document.getElementById('letterColorInput').value = scheme.text;
            
            // Update shape stroke color
            document.getElementById('triangleColorPicker').value = scheme.stroke;
            document.getElementById('triangleColorInput').value = scheme.stroke;
            
            shapeSettings.color = scheme.stroke;
            
            
            if (!animationFrame) {
                drawSquare();
            }
        }

        // Replace the dropdown event listener with a button click handler
        // Note: we keep the same element ID 'colorSchemeSelect' to maintain compatibility
        let currentSchemeIndex = 0;
        document.getElementById('colorSchemeSelect').addEventListener('click', function() {
            currentSchemeIndex = (currentSchemeIndex + 1) % 5;
            // Simulate the original dropdown change event by setting a value
            this.value = currentSchemeIndex.toString();
            // Use the existing color scheme application function
            applyColorScheme(currentSchemeIndex);
        });

        // Update the turbulence function for independent movement
        function updateTurbulence() {
            const now = Date.now();
            const turbulenceStrength = parseFloat(document.getElementById('turbulenceInput').value);
            const deltaTime = now - turbulence.lastTime;
            const interpolationFactor = 0.08;
            
            // Update forces periodically
            if (now - turbulence.lastTime > turbulence.changeInterval) {
                turbulence.lastTime = now;
                
                // Update target forces for each word independently
                turbulence.words.forEach(word => {
                    const angle = Math.random() * Math.PI * 2;
                    const magnitude = 0.00005 * turbulenceStrength;
                    word.targetForceX = Math.cos(angle + word.phase) * magnitude;
                    word.targetForceY = Math.sin(angle + word.phase) * magnitude;
                });
            }
            
            // Apply forces to each word separately
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach((letterSet, index) => {
                const wordForces = turbulence.words[index];
                
                // Smooth interpolation for this word's forces
                wordForces.currentForceX += (wordForces.targetForceX - wordForces.currentForceX) * interpolationFactor;
                wordForces.currentForceY += (wordForces.targetForceY - wordForces.currentForceY) * interpolationFactor;
                
                // Apply forces to letters in this word
                letterSet.forEach(letter => {
                    if (letter.physicsBody) {
                        const randomVariation = 0.15;
                        const forceX = wordForces.currentForceX * (1 + (Math.random() - 0.5) * randomVariation);
                        const forceY = wordForces.currentForceY * (1 + (Math.random() - 0.5) * randomVariation);
                        
                        Body.applyForce(letter.physicsBody, letter.physicsBody.position, {
                            x: forceX * letter.physicsBody.mass,
                            y: forceY * letter.physicsBody.mass
                        });
                    }
                });
            });
            
            // Apply separate forces to floating image
            if (floatingImage && floatingImageOscillation.physicsBody) {
                const imageForces = turbulence.words[3];
                imageForces.currentForceX += (imageForces.targetForceX - imageForces.currentForceX) * interpolationFactor;
                imageForces.currentForceY += (imageForces.targetForceY - imageForces.currentForceY) * interpolationFactor;
                
                const forceX = imageForces.currentForceX * floatingImageOscillation.physicsBody.mass;
                const forceY = imageForces.currentForceY * floatingImageOscillation.physicsBody.mass;
                
                Body.applyForce(
                    floatingImageOscillation.physicsBody, 
                    floatingImageOscillation.physicsBody.position, 
                    { x: forceX, y: forceY }
                );
            }
        }

        // Update the turbulence slider event listener
        document.getElementById('turbulenceInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('turbulenceValue').textContent = value.toFixed(1);
            turbulence.force = value;
        });

        // Update the funky stroke settings
        let funkyStrokeSettings = {
            color: '#FF4B1F',
            width: 1,
            effect: 'wave',
            amplitude: 12,
            waveFrequency: 4,    // Controls number of waves
            waveDepth: 1,        // Controls wave height
            waveLayers: 1,       // Number of overlapping waves
            wavePhase: 0,        // Wave offset
            baseRadius: 0.6,      // Base size relative to letter
            roundness: 0    // New property for controlling curve smoothness
        };

        // Update the drawFunkyStroke function to reduce distortion
        function drawFunkyStroke(letter) {
            if (!letter) return;
            
            const scale = parseFloat(document.getElementById('funkyStrokeWidthInput').value);
            if (scale <= 0) return;

            ctx.save();
            ctx.fillStyle = funkyStrokeSettings.color;
            
            // Get points around the letter
            const points = getLetterPoints(letter);
            
            // Draw the effect with roundness
            ctx.beginPath();
            
            if (funkyStrokeSettings.roundness > 0) {
                // Draw rounded path
                for (let i = 0; i <= points.length; i++) {
                    const point = points[i % points.length];
                    const nextPoint = points[(i + 1) % points.length];
                    const prevPoint = points[(i - 1 + points.length) % points.length];
                    
                    let r = scale * 10;
                    
                    // Add wave effect
                    for (let layer = 0; layer < funkyStrokeSettings.waveLayers; layer++) {
                        const layerFreq = funkyStrokeSettings.waveFrequency * (layer + 1);
                        const layerPhase = (funkyStrokeSettings.wavePhase * Math.PI / 180) * (layer + 1);
                        const layerDepth = funkyStrokeSettings.waveDepth / (layer + 1);
                        r += Math.sin(point.angle * layerFreq + layerPhase) * 
                             funkyStrokeSettings.amplitude * layerDepth * scale * 0.5;
                    }
                    
                    const px = point.x + Math.cos(point.angle) * r;
                    const py = point.y + Math.sin(point.angle) * r;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        const roundness = funkyStrokeSettings.roundness * 0.3;
                        const cp1x = px + (nextPoint.x - prevPoint.x) * roundness;
                        const cp1y = py + (nextPoint.y - prevPoint.y) * roundness;
                        ctx.quadraticCurveTo(cp1x, cp1y, px, py);
                    }
                }
            } else {
                // Draw sharp path
                points.forEach((point, i) => {
                    let r = scale * 10;
                    
                    for (let layer = 0; layer < funkyStrokeSettings.waveLayers; layer++) {
                        const layerFreq = funkyStrokeSettings.waveFrequency * (layer + 1);
                        const layerPhase = (funkyStrokeSettings.wavePhase * Math.PI / 180) * (layer + 1);
                        const layerDepth = funkyStrokeSettings.waveDepth / (layer + 1);
                        r += Math.sin(point.angle * layerFreq + layerPhase) * 
                             funkyStrokeSettings.amplitude * layerDepth * scale * 0.5;
                    }
                    
                    const px = point.x + Math.cos(point.angle) * r;
                    const py = point.y + Math.sin(point.angle) * r;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                });
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Helper function to get letter points
        function getLetterPoints(letter) {
            const points = [];
            const letterSize = letter.size;
            const steps = 60;
            
            for (let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI * 2;
                points.push({
                    x: letter.x,
                    y: letter.y,
                    angle: angle
                });
            }
            
            return points;
        }

        // Add these wave settings to control the stroke appearance
        const waveSettings = {
            frequency: 4,    // Controls number of waves
            depth: 1,        // Controls wave height
            layers: 1,       // Number of overlapping waves
            phase: 0         // Wave offset
        };

        // Split drawLetterOnly into two separate functions
        function drawLetterOutline(letter) {
            if (!letter || !letter.physicsBody) return;
            
            // Get base stroke width from input
            const baseStrokeWidth = parseInt(document.getElementById('shapeStrokeWidthInput').value);
            if (baseStrokeWidth <= 0) return;
            
            // Calculate scale factor based on current letter size vs base size
            const scaleFactor = letter.size / letter.maxSize;
            // Apply scale factor to stroke width
            const scaledStrokeWidth = baseStrokeWidth * scaleFactor;
            
            if (letter.outlinePoints && letter.outlinePoints.length > 0) {
                ctx.save();
                ctx.strokeStyle = document.getElementById('triangleColorInput').value;
                ctx.lineWidth = scaledStrokeWidth;  // Use scaled stroke width
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                letter.outlinePoints.forEach((point, i) => {
                    const worldX = letter.x + point.relX;
                    const worldY = letter.y + point.relY;
                    
                    if (i === 0) {
                        ctx.moveTo(worldX, worldY);
                    } else {
                        ctx.lineTo(worldX, worldY);
                    }
                });
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawLetterText(letter) {
            if (!letter || !letter.physicsBody) return;
            
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw the letter fill
            ctx.fillStyle = document.getElementById('letterColorInput').value;
            ctx.font = `${letter.size}px ${currentFont}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter.letter, letter.x, letter.y);
            
            // Draw letter stroke on top
            const strokeWidth = parseInt(document.getElementById('strokeWidthInput').value);
            if (strokeWidth > 0) {
                ctx.strokeStyle = document.getElementById('letterColorInput').value;
                ctx.lineWidth = strokeWidth;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.strokeText(letter.letter, letter.x, letter.y);
            }
            
            ctx.restore();
        }

        // Keep all the existing mouse event handlers and path drawing code

        // Add noise function for more organic randomness
        function noise(x, y, seed = 0) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            return ((X + Y * 7 + seed * 13) & 255) / 255.0;
        }

        document.getElementById('funkyStrokeColorPicker').addEventListener('input', function(e) {
            const color = e.target.value;
            document.getElementById('funkyStrokeColorInput').value = color;
            funkyStrokeSettings.color = color;
        });

        document.getElementById('funkyStrokeColorInput').addEventListener('input', function(e) {
            const color = e.target.value;
            document.getElementById('funkyStrokeColorPicker').value = color;
            funkyStrokeSettings.color = color;
        });

        document.getElementById('funkyStrokeWidthInput').addEventListener('input', function(e) {
            const width = parseInt(e.target.value);
            document.getElementById('funkyStrokeWidthValue').textContent = width;
            funkyStrokeSettings.width = width;
        });

        document.getElementById('funkyEffectSelect').addEventListener('change', function(e) {
            funkyStrokeSettings.effect = e.target.value;
            document.getElementById('funkyEffectValue').textContent = e.target.value;
        });

        // Add event listener for spikiness slider
        document.getElementById('funkySpikynessInput').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('funkySpikynessValue').textContent = value.toFixed(1);
            funkyStrokeSettings.spikiness = value;
        });

        document.getElementById('waveFrequencyInput').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('waveFrequencyValue').textContent = value;
            funkyStrokeSettings.waveFrequency = value;
        });

        document.getElementById('waveDepthInput').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('waveDepthValue').textContent = value.toFixed(1);
            funkyStrokeSettings.waveDepth = value;
        });

        document.getElementById('waveLayersInput').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('waveLayersValue').textContent = value;
            funkyStrokeSettings.waveLayers = value;
        });

        document.getElementById('wavePhaseInput').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('wavePhaseValue').textContent = value;
            funkyStrokeSettings.wavePhase = value;
        });

        let currentFont = 'Arial'; // Default system font

        document.getElementById('fontSelect').addEventListener('change', function(e) {
            currentFont = e.target.value;
            
            // Regenerate outline points for all letters with new font
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    letter.outlinePoints = generateLetterOutline(letter);
                });
            });
            
            // Redraw if not animating
            if (!animationFrame) {
                drawSquare();
            }
        });

        // Add the event listener
        document.getElementById('funkyRoundnessInput').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('funkyRoundnessValue').textContent = value;
            funkyStrokeSettings.roundness = value;
        });

        // Make sure the canvas is initialized with a background
        window.onload = function() {
            // Initial background fill
            ctx.fillStyle = document.getElementById('backgroundColorInput').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        };

        // Update background color listener
        document.getElementById('backgroundColorInput').addEventListener('input', function(e) {
            drawLetters(); // This will redraw everything including the new background
        });

        // Update LFO settings and animation
        let lfoSettings = {
            active: true, // Always active now
            speed: 0.5,
            min: 0,
            max: 360
        };

        // Add animation loop for the LFO
        function animateLFO() {
            if (lfoSettings.active) {
                // Get the current wave phase value
                let currentPhase = funkyStrokeSettings.wavePhase;
                
                // Update the phase
                currentPhase = (currentPhase + lfoSettings.speed) % 360;
                
                // Update the funky stroke settings
                funkyStrokeSettings.wavePhase = currentPhase;
                
                // Update the input and display
                const phaseInput = document.getElementById('wavePhaseInput');
                const phaseValue = document.getElementById('wavePhaseValue');
                if (phaseInput && phaseValue) {
                    phaseInput.value = currentPhase;
                    phaseValue.textContent = Math.round(currentPhase);
                }
                
                // Redraw
                requestAnimationFrame(drawLetters);
            }
            
            // Continue the animation loop
            requestAnimationFrame(animateLFO);
        }

        // Start the animation
        animateLFO();

        // Update wave phase input listener to sync with animation
        document.getElementById('wavePhaseInput').addEventListener('input', function(e) {
            funkyStrokeSettings.wavePhase = parseFloat(e.target.value);
        });

        // Update the triangle/shape color picker event listeners
        document.getElementById('triangleColorPicker').addEventListener('input', function(e) {
            shapeSettings.color = e.target.value;
            document.getElementById('triangleColorInput').value = e.target.value;
        });

        document.getElementById('triangleColorInput').addEventListener('input', function(e) {
            let color = e.target.value;
            if (!color.startsWith('#')) {
                color = '#' + color;
            }
            if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                shapeSettings.color = color;
                document.getElementById('triangleColorPicker').value = color;
            }
        });

        document.getElementById('triangleSizeInput').addEventListener('input', function(e) {
            shapeSettings.size = parseInt(e.target.value);
            document.getElementById('triangleSizeValue').textContent = e.target.value;
        });

        document.getElementById('triangleRotationInput').addEventListener('input', function(e) {
            shapeSettings.rotation = parseInt(e.target.value);
            document.getElementById('triangleRotationValue').textContent = e.target.value;
            
            const baseRotation = shapeSettings.rotation * Math.PI / 180;
            
            // Update rotation for all existing shapes to the same value
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    if (letter.trianglePoints) {
                        letter.trianglePoints.forEach(point => {
                            point.rotation = baseRotation;
                        });
                    }
                });
            });
        });

        document.getElementById('triangleDensityInput').addEventListener('input', function(e) {
            shapeSettings.density = parseInt(e.target.value);
            document.getElementById('triangleDensityValue').textContent = e.target.value;
            
            // Regenerate shapes for all letters
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    const letterPoints = getLetterPixels(letter);
                    letter.trianglePoints = [];
                    const numShapes = shapeSettings.density * 3;
                    
                    for (let i = 0; i < numShapes; i++) {
                        if (letterPoints.length > 0) {
                            const point = letterPoints[Math.floor(Math.random() * letterPoints.length)];
                            const jitter = shapeSettings.size * 0.2;
                            const offset = {
                                x: point.x + (Math.random() - 0.5) * jitter,
                                y: point.y + (Math.random() - 0.5) * jitter,
                                rotation: shapeSettings.rotation * Math.PI / 180 + (Math.random() - 0.5) * Math.PI * 0.5,
                                shape: shapeSettings.shapes[Math.floor(Math.random() * shapeSettings.shapes.length)]
                            };
                            letter.trianglePoints.push(offset);
                        }
                    }
                });
            });
        });

        // Add this with the other global settings at the top of the script
        let triangleSettings = {
            color: '#4AFF00',
            size: 20,
            rotation: 0,
            density: 3
        };

        // Add this helper function to sample points from text
        function getLetterPixels(letter) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Make canvas big enough for the letter
            const padding = letter.size;
            tempCanvas.width = letter.size * 2;
            tempCanvas.height = letter.size * 2;
            
            // Draw the letter
            tempCtx.font = `${letter.size}px ${currentFont}`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(letter.letter, tempCanvas.width/2, tempCanvas.height/2);
            
            // Get pixel data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const pixels = imageData.data;
            
            // Collect points where letter exists
            const points = [];
            for(let y = 0; y < tempCanvas.height; y += 2) {
                for(let x = 0; x < tempCanvas.width; x += 2) {
                    const i = (y * tempCanvas.width + x) * 4;
                    if(pixels[i + 3] > 0) { // If pixel is not transparent
                        points.push({
                            x: x - tempCanvas.width/2,
                            y: y - tempCanvas.height/2
                        });
                    }
                }
            }
            return points;
        }

        // Update triangle settings to shape settings
        let shapeSettings = {
            color: '#4AFF00',
            size: 20,
            rotation: 0,
            density: 3,
            shapes: ['triangle', 'circle', 'oval', 'roundedTriangle'] // Available shape types
        };

        // Update the drawShape function with simpler rounded corners
        function drawShape(ctx, type, size) {
            switch(type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'oval':
                    ctx.beginPath();
                ctx.save();
                    ctx.scale(1, 0.6);
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.restore();
                    ctx.fill();
                    break;
                    
                case 'roundedTriangle':
                case 'triangle':
                    const radius = size/12; // Corner radius
                    const h = size * 0.866; // Triangle height
                
                ctx.beginPath();
                    
                    // Calculate the three points of the triangle
                    const topX = 0;
                    const topY = -h/2;
                    const rightX = size/2;
                    const rightY = h/2;
                    const leftX = -size/2;
                    const leftY = h/2;
                    
                    // Start at top
                    ctx.moveTo(topX + Math.cos(Math.PI/6) * radius, 
                              topY + Math.sin(Math.PI/6) * radius);
                    
                    // Right side
                    ctx.arcTo(rightX, rightY, 0, rightY, radius);
                    
                    // Bottom side
                    ctx.arcTo(leftX, leftY, leftX, leftY - radius, radius);
                    
                    // Left side
                    ctx.arcTo(leftX, topY, topX, topY, radius);
                    
                    // Back to top
                    ctx.arcTo(topX, topY, rightX, topY, radius);
                    
                ctx.closePath();
                ctx.fill();
                    break;
                    
                default:
                    // Use same rounded triangle as above
                    const r = size/12;
                    const height = size * 0.866;
                    
                    ctx.beginPath();
                    ctx.moveTo(0 + Math.cos(Math.PI/6) * r, 
                              -height/2 + Math.sin(Math.PI/6) * r);
                    ctx.arcTo(size/2, height/2, 0, height/2, r);
                    ctx.arcTo(-size/2, height/2, -size/2, height/2 - r, r);
                    ctx.arcTo(-size/2, -height/2, 0, -height/2, r);
                    ctx.arcTo(size/2, -height/2, size/2, height/2, r);
                    ctx.closePath();
                    ctx.fill();
            }
        }

        // Update addLetter to store shape type with each point
        function addLetter(isSecondSet = false, isThirdSet = false) {
            const targetLetters = isSecondSet ? secondLetterObjects : isThirdSet ? thirdLetterObjects : letterObjects;
            const lettersText = isSecondSet ? secondLetters : isThirdSet ? thirdLetters : letters;
            const currentPathPoints = isSecondSet ? secondPathPoints : isThirdSet ? thirdPathPoints : pathPoints;

            if (targetLetters.length >= lettersText.length || currentPathPoints.length < 2) return;
            
            try {
                let letter = lettersText[targetLetters.length];
                const baseSize = parseInt(letterSizeInput.value) || 60;
                const randomRange = parseInt(randomSizeInput.value) || 0;
                const size = baseSize + (Math.random() * randomRange * 2) - randomRange;

                // Calculate total path length with error checking
                const totalLength = currentPathPoints.reduce((total, point, i) => {
                    if (i === 0) return 0;
                    const dx = point.x - currentPathPoints[i-1].x;
                    const dy = point.y - currentPathPoints[i-1].y;
                    return total + Math.sqrt(dx * dx + dy * dy);
                }, 0);

                if (totalLength === 0) return; // Prevent division by zero

                const spacing = totalLength / (lettersText.length - 1);
                const targetDistance = targetLetters.length * spacing;
                let currentDistance = 0;
                let x = currentPathPoints[0].x;
                let y = currentPathPoints[0].y;
                
                for (let i = 1; i < currentPathPoints.length; i++) {
                    const dx = currentPathPoints[i].x - currentPathPoints[i-1].x;
                    const dy = currentPathPoints[i].y - currentPathPoints[i-1].y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    
                    if (currentDistance + segmentLength >= targetDistance) {
                        const ratio = (targetDistance - currentDistance) / segmentLength;
                        x = currentPathPoints[i-1].x + dx * ratio;
                        y = currentPathPoints[i-1].y + dy * ratio;
                        break;
                    }
                    currentDistance += segmentLength;
                }

                const speedMultiplier = parseFloat(document.getElementById('oscillationSpeedInput').value) || 1;
            
                let newLetter = {
                    letter: letter,
                    x: x,
                    y: y,
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    size: size,
                    maxSize: size,
                    growth: 1,
                    progress: 1,
                    trianglePoints: [], // Initialize empty array for triangle points
                    oscillation: {
                        angle: Math.random() * Math.PI * 2,
                        speed: (0.02 + Math.random() * 0.02) * speedMultiplier,
                        radius: 4 + Math.random() * 4,
                        phase: 1,
                        smoothX: 0,
                        smoothY: 0,
                        velocityX: 0,
                        velocityY: 0,
                        secondaryAngle: Math.random() * Math.PI * 2,
                        secondarySpeed: (0.01 + Math.random() * 0.01) * speedMultiplier,
                        currentRadius: 0,
                        targetRadius: 4 + Math.random() * 4
                    },
                    physicsBody: null,
                    outlinePoints: [], // Add this new property
                };

                // Generate the outline points once when creating the letter
                newLetter.outlinePoints = generateLetterOutline(newLetter);

                // Create circular physics body for the letter
                const radius = newLetter.size / 2;
                const body = Bodies.circle(x, y, radius, {
                    friction: 0.1,
                    restitution: 0.3,
                    density: 0.0001,
                    frictionAir: 0.1,
                    collisionFilter: {
                        group: -currentDrawingSet,
                        category: Math.pow(2, currentDrawingSet),
                        mask: 0xFFFFFF ^ Math.pow(2, currentDrawingSet)
                    },
                    render: {
                        visible: false
                    },
                    slop: 0
                });

                // Get the previous letter in the same word
                const letterSet = targetLetters;
                const prevLetter = letterSet[letterSet.length - 1];

                // Only create constraint if there's a previous letter
                if (prevLetter && prevLetter.physicsBody) {
                    const constraint = Constraint.create({
                        bodyA: prevLetter.physicsBody,
                        bodyB: body,
                        stiffness: 0.001,    // Very loose connection
                        damping: 0.1,        // Low damping for more natural movement
                        length: radius * 2,   // More space between letters
                        render: {
                            visible: false
                        }
                    });
                    World.add(engine.world, constraint);
                }

                // Add body to world regardless of constraint
                World.add(engine.world, body);
                newLetter.physicsBody = body;
                physicsObjects.set(body.id, newLetter);

                // Generate and store triangle points
                const letterPoints = getLetterPixels(newLetter);
                const numTriangles = triangleSettings.density * 3;
                
                // When generating points, use the same rotation for all shapes
                const baseRotation = shapeSettings.rotation * Math.PI / 180;
                
                for (let i = 0; i < numTriangles; i++) {
                    if (letterPoints.length > 0) {
                        const point = letterPoints[Math.floor(Math.random() * letterPoints.length)];
                        const jitter = shapeSettings.size * 0.2;
                        const offset = {
                            x: point.x + (Math.random() - 0.5) * jitter,
                            y: point.y + (Math.random() - 0.5) * jitter,
                            rotation: baseRotation, // Use same rotation for all shapes
                            shape: shapeSettings.shapes[Math.floor(Math.random() * shapeSettings.shapes.length)]
                        };
                        newLetter.trianglePoints.push(offset);
                    }
                }

                targetLetters.push(newLetter);
            } catch (error) {
                console.error('Error in addLetter:', error);
                reset();
            }
        }

        // Update drawLetterTriangles to use the new shape drawing
        function drawLetterTriangles(letter) {
            if (!letter || !letter.physicsBody || !letter.trianglePoints) return;
            
            const shapeSize = shapeSettings.size;
            const pos = letter.physicsBody.position;
            
            letter.trianglePoints.forEach(point => {
                ctx.save();
                ctx.fillStyle = shapeSettings.color; // Use shapeSettings.color instead of triangleSettings.color
                ctx.translate(pos.x + point.x, pos.y + point.y);
                ctx.rotate(point.rotation);
                
                drawShape(ctx, point.shape, shapeSize);
                
                ctx.restore();
            });
        }

        // Update the density slider event listener
        document.getElementById('triangleDensityInput').addEventListener('input', function(e) {
            shapeSettings.density = parseInt(e.target.value);
            document.getElementById('triangleDensityValue').textContent = e.target.value;
            
            // Regenerate shapes for all letters
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    const letterPoints = getLetterPixels(letter);
                    letter.trianglePoints = [];
                    const numShapes = shapeSettings.density * 3;
                    
                    for (let i = 0; i < numShapes; i++) {
                        if (letterPoints.length > 0) {
                            const point = letterPoints[Math.floor(Math.random() * letterPoints.length)];
                            const jitter = shapeSettings.size * 0.2;
                            const offset = {
                                x: point.x + (Math.random() - 0.5) * jitter,
                                y: point.y + (Math.random() - 0.5) * jitter,
                                rotation: shapeSettings.rotation * Math.PI / 180 + (Math.random() - 0.5) * Math.PI * 0.5,
                                shape: shapeSettings.shapes[Math.floor(Math.random() * shapeSettings.shapes.length)]
                            };
                            letter.trianglePoints.push(offset);
                        }
                    }
                });
            });
        });

        // Update the rotation slider event listener
        document.getElementById('triangleRotationInput').addEventListener('input', function(e) {
            shapeSettings.rotation = parseInt(e.target.value);
            document.getElementById('triangleRotationValue').textContent = e.target.value;
            
            const baseRotation = shapeSettings.rotation * Math.PI / 180;
            
            // Update rotation for all existing shapes to the same value
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    if (letter.trianglePoints) {
                        letter.trianglePoints.forEach(point => {
                            point.rotation = baseRotation;
                        });
                    }
                });
            });
        });

        // Replace the circle-based particle placement with letter shape sampling
        function initParticles() {
          const textCanvas = document.createElement('canvas');
          const textCtx = textCanvas.getContext('2d');
          
          // Set canvas size to match main canvas
          textCanvas.width = canvas.width;
          textCanvas.height = canvas.height;
          
          // Draw text to sample from
          textCtx.fillStyle = letterColor;
          textCtx.font = `${letterSize}px ${currentFont || 'Arial'}`;
          textCtx.fillText(first, canvas.width/2 - 150, canvas.height/2);
          textCtx.fillText(second, canvas.width/2, canvas.height/2);
          textCtx.fillText(third, canvas.width/2 + 150, canvas.height/2);
          
          // Get image data to sample points
          const imageData = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
          const pixels = imageData.data;
          
          particles = [];
          
          // Sample points from the text
          for (let y = 0; y < textCanvas.height; y += 4) {
            for (let x = 0; x < textCanvas.width; x += 4) {
              const index = (y * textCanvas.width + x) * 4;
              // If we find a non-transparent pixel (part of the text)
              if (pixels[index + 3] > 0) {
                if (Math.random() < triangleDensity/10) { // Use density parameter
                  particles.push({
                    x: x + (Math.random() - 0.5) * 5,
                    y: y + (Math.random() - 0.5) * 5,
                    size: triangleSize,
                    rotation: triangleRotation + (Math.random() - 0.5) * 30,
                    color: triangleColor
                  });
                }
              }
            }
          }
        }

        // Update the input element's attributes
        document.getElementById('triangleSizeInput').setAttribute('max', '100');

        // Update the label text from "Triangle Size" to "Funky Stroke Size"
        const triangleSizeLabel = document.querySelector('label[for="triangleSizeInput"]');
        if (triangleSizeLabel) {
            triangleSizeLabel.textContent = 'Funky Stroke Size ';
            // Add back the span element that shows the value
            triangleSizeLabel.appendChild(document.getElementById('triangleSizeValue'));
            triangleSizeLabel.appendChild(document.createTextNode('px'));
        }

        // Update the shapeSettings default size
        shapeSettings = {
            ...shapeSettings,
            size: 20, // Keep default but now can go up to 100
        };

        // Update the triangleSettings default size
        triangleSettings = {
            ...triangleSettings,
            size: 20, // Keep default but now can go up to 100
        };

        // Add this near the top of your script with other initialization code
        const defaultSettings = {
            backgroundColor: '#242AD6',
            letterColor: '#24ABFF',
            letterSize: 89,
            strokeWidth: 15,
            turbulence: 0.2,
            triangleColor: '#4AFF00',
            funkyStrokeSize: 0,
            triangleRotation: 0,
            triangleDensity: 3,
            shapeStrokeWidth: 60,
            sizeOscillation: 50
        };

        // Add function to apply default settings
        function applyDefaultSettings() {
            // Background color
            document.getElementById('backgroundColorPicker').value = defaultSettings.backgroundColor;
            document.getElementById('backgroundColorInput').value = defaultSettings.backgroundColor;
            
            // Letter color
            document.getElementById('letterColorPicker').value = defaultSettings.letterColor;
            document.getElementById('letterColorInput').value = defaultSettings.letterColor;
            
            // Letter size
            document.getElementById('letterSizeInput').value = defaultSettings.letterSize;
            document.getElementById('letterSizeValue').textContent = defaultSettings.letterSize;
            
            // Stroke width
            document.getElementById('strokeWidthInput').value = defaultSettings.strokeWidth;
            document.getElementById('strokeWidthValue').textContent = defaultSettings.strokeWidth;
            
            // Turbulence
            document.getElementById('turbulenceInput').value = defaultSettings.turbulence;
            document.getElementById('turbulenceValue').textContent = defaultSettings.turbulence;
            
            // Triangle/Shape color
            document.getElementById('triangleColorPicker').value = defaultSettings.triangleColor;
            document.getElementById('triangleColorInput').value = defaultSettings.triangleColor;
            
            // Funky stroke size (formerly triangle size)
            document.getElementById('triangleSizeInput').value = defaultSettings.funkyStrokeSize;
            document.getElementById('triangleSizeValue').textContent = defaultSettings.funkyStrokeSize;
            
            // Triangle rotation
            document.getElementById('triangleRotationInput').value = defaultSettings.triangleRotation;
            document.getElementById('triangleRotationValue').textContent = defaultSettings.triangleRotation;
            
            // Triangle density
            document.getElementById('triangleDensityInput').value = defaultSettings.triangleDensity;
            document.getElementById('triangleDensityValue').textContent = defaultSettings.triangleDensity;
            
            // Shape stroke width
            document.getElementById('shapeStrokeWidthInput').value = defaultSettings.shapeStrokeWidth;
            document.getElementById('shapeStrokeWidthValue').textContent = defaultSettings.shapeStrokeWidth;
            
            // Size oscillation
            document.getElementById('sizeOscillationInput').value = defaultSettings.sizeOscillation;
            document.getElementById('sizeOscillationValue').textContent = defaultSettings.sizeOscillation;
            
            // Update the settings objects
            shapeSettings = {
                ...shapeSettings,
                color: defaultSettings.triangleColor,
                size: defaultSettings.funkyStrokeSize,
                rotation: defaultSettings.triangleRotation,
                density: defaultSettings.triangleDensity
            };
            
            triangleSettings = {
                ...triangleSettings,
                color: defaultSettings.triangleColor,
                size: defaultSettings.funkyStrokeSize,
                rotation: defaultSettings.triangleRotation,
                density: defaultSettings.triangleDensity
            };
        }

        // Add event listener for ESC key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Reset all mouse states
                isDrawingPath = false;
                isDragging = false;
                
                // Just reset the animation without changing settings
                reset();
            }
        });

        // Apply default settings on page load
        window.addEventListener('load', function() {
            applyDefaultSettings();
        });

        // Add event listeners for text inputs
        textInput.addEventListener('input', function() {
            letters = this.value.toUpperCase();
            currentDrawingSet = 1; // Reset to first word
            reset();
        });

        secondTextInput.addEventListener('input', function() {
            secondLetters = this.value.toUpperCase();
            currentDrawingSet = 2; // Set to second word
            reset();
        });

        thirdTextInput.addEventListener('input', function() {
            thirdLetters = this.value.toUpperCase();
            currentDrawingSet = 3; // Set to third word
            reset();
        });

        // Update the Reset Animation button event listener
        document.getElementById('resetBtn').addEventListener('click', function() {
            // Reset all mouse states
            isDrawingPath = false;
            isDragging = false;
            
            // Just reset the animation without changing settings
            reset();
        });

        // Add event listener for the inflate slider
        document.getElementById('inflateInput').addEventListener('input', function(e) {
            const value = parseFloat(e.target.value);
            document.getElementById('inflateValue').textContent = Math.abs(value).toFixed(2);
            
            // Update engine gravity immediately
            engine.world.gravity.y = -value;
        });

        // Add aspect ratio handling
        const aspectRatioSelect = document.getElementById('aspectRatioSelect');
        
        // Update the updateCanvasSize function to handle the new layout
        function updateCanvasSize() {
            const ratio = aspectRatioSelect.value;
            const [width, height] = ratio.split(':').map(Number);
            
            // Base size calculation (maintain similar area to original 600x600)
            const baseArea = 600 * 600;
            const scale = Math.sqrt(baseArea / (width * height));
            
            const newWidth = Math.round(width * scale);
            const newHeight = Math.round(height * scale);
            
            // Check if we need to adjust for available space
            const leftPanel = document.querySelector('.left-controls');
            const rightPanel = document.querySelector('.controls');
            const availableWidth = window.innerWidth - (leftPanel.offsetWidth + rightPanel.offsetWidth + 60); // 60px for gaps
            
            // If canvas would be too wide, scale it down
            let finalWidth = newWidth;
            let finalHeight = newHeight;
            if (newWidth > availableWidth && availableWidth > 0) {
                const scaleFactor = availableWidth / newWidth;
                finalWidth = availableWidth;
                finalHeight = Math.round(newHeight * scaleFactor);
            }
            
            canvas.width = finalWidth;
            canvas.height = finalHeight;
            
            // Update physics engine walls
            updatePhysicsWalls();
            
            // Update bottom controls width
            updateBottomControlsWidth();
        }

        // Add this new function to handle physics walls update
        function updatePhysicsWalls() {
            // Remove existing walls
            walls.forEach(wall => Matter.World.remove(engine.world, wall));
            walls.length = 0;
            
            // Create new walls based on current canvas dimensions
            const wallThickness = 60;
            const wallOptions = { 
                isStatic: true,
                render: { visible: false }
            };
            
            // Top wall
            walls.push(Bodies.rectangle(
                canvas.width / 2, -wallThickness / 2,
                canvas.width + wallThickness * 2, wallThickness,
                wallOptions
            ));
            
            // Bottom wall
            walls.push(Bodies.rectangle(
                canvas.width / 2, canvas.height + wallThickness / 2,
                canvas.width + wallThickness * 2, wallThickness,
                wallOptions
            ));
            
            // Left wall
            walls.push(Bodies.rectangle(
                -wallThickness / 2, canvas.height / 2,
                wallThickness, canvas.height + wallThickness * 2,
                wallOptions
            ));
            
            // Right wall
            walls.push(Bodies.rectangle(
                canvas.width + wallThickness / 2, canvas.height / 2,
                wallThickness, canvas.height + wallThickness * 2,
                wallOptions
            ));
            
            // Add new walls to world
            World.add(engine.world, walls);
        }

        // Add window resize handler to adjust layout
        window.addEventListener('resize', function() {
            updateCanvasSize();
            updateBottomControlsWidth();
        });

        // Fix the reset functionality
        function reset() {
            // Reset all mouse states
            isMouseDown = false;
            canStartDrawing = false;
            isDrawingPath = false;
            isDragging = false;
            
            // Store floating image reference before clearing
            const existingFloatingImage = floatingImage;
            const existingFloatingImageOscillation = { ...floatingImageOscillation };
            
            // Clear physics world
            World.clear(engine.world);
            Engine.clear(engine);
            
            // Get current inflate value for gravity
            const inflateValue = -parseFloat(document.getElementById('inflateInput').value);
            
            // Recreate engine with current gravity
            engine = Engine.create({
                gravity: { x: 0, y: inflateValue },
                constraintIterations: 4,
                positionIterations: 8,
                velocityIterations: 8,
                enableSleeping: false
            });
            
            // Create new mouse and constraint
            const mouse = Matter.Mouse.create(canvas);
            const mouseConstraint = Matter.MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: {
                        visible: false
                    }
                }
            });
            
            // Add mouse constraint to world
            World.add(engine.world, mouseConstraint);
            
            // Clear arrays and reset state
            letterObjects.length = 0;
            secondLetterObjects.length = 0;
            thirdLetterObjects.length = 0;
            pathPoints = [];
            secondPathPoints = [];
            thirdPathPoints = [];
            
            // Reset drawing state
            hasDrawnPath = false;
            currentDrawingSet = 1;
            
            // Cancel existing animation frame
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Clear only the canvas area
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = document.getElementById('backgroundColorInput').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add walls back to world
            World.add(engine.world, walls);
            
            // Restore floating image if it existed
            if (existingFloatingImage) {
                floatingImage = existingFloatingImage;
                
                // Create new physics body for floating image
                const imageBody = Bodies.circle(
                    existingFloatingImageOscillation.x || canvas.width / 2,
                    existingFloatingImageOscillation.y || canvas.height / 2,
                    (floatingImage.width * existingFloatingImageOscillation.scale) / 2,
                    {
                        friction: 0.1,
                        restitution: 0.3,
                        density: 0.0001,
                        frictionAir: 0.1,
                        collisionFilter: {
                            category: 0x0008,  // Category for image
                            mask: 0xFFFFFF     // Collide with everything
                        }
                    }
                );
                
                // Restore floating image physics body
                floatingImageOscillation = {
                    ...existingFloatingImageOscillation,
                    physicsBody: imageBody
                };
                
                World.add(engine.world, imageBody);
            }
            
            // Set a small delay before enabling path drawing
            setTimeout(() => {
                isDrawingPath = true;
                canStartDrawing = true;
            }, 100);
            
            // Start fresh animation
            animate();
            
            // Update walls for current canvas size
            updatePhysicsWalls();
        }

        // Update the aspect ratio change handler
        aspectRatioSelect.addEventListener('change', function() {
            updateCanvasSize();
            reset(); // This will now properly reset with new dimensions
        });

        // Update ESC key handler
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                reset(); // This will now properly reset with current dimensions
            }
        });

        // Update Reset Animation button handler
        document.getElementById('resetBtn').addEventListener('click', function() {
            reset(); // This will now properly reset with current dimensions
        });

        // Add this function to handle mouse scaling for different canvas sizes
        function updateMouseScale() {
            const canvasRect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;
            
            mouse.scale.x = scaleX;
            mouse.scale.y = scaleY;
        }

        // Add event listener for window resize
        window.addEventListener('resize', updateMouseScale);

        // Call updateMouseScale initially and after canvas size changes
        updateMouseScale();
        aspectRatioSelect.addEventListener('change', function() {
            updateCanvasSize();
            reset();
            updateMouseScale();
        });

        // Add event listener for the slider
        document.getElementById('outerStrokeWavinessInput').addEventListener('input', function() {
            const value = parseFloat(this.value);
            document.getElementById('outerStrokeWavinessValue').textContent = value.toFixed(2);
            
            // Regenerate outline points for all letters
            [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                letterSet.forEach(letter => {
                    letter.outlinePoints = generateLetterOutline(letter);
                });
            });
        });

        // Add a window resize handler to ensure alignment stays correct
        window.addEventListener('resize', function() {
            // Force bottom controls to match canvas width on window resize
            const bottomControls = document.querySelector('.bottom-controls');
            if (bottomControls && canvas) {
                bottomControls.style.width = `${canvas.width}px`;
            }
        });

        // Call this once on initial load to set correct width
        document.addEventListener('DOMContentLoaded', function() {
            const bottomControls = document.querySelector('.bottom-controls');
            if (bottomControls && canvas) {
                bottomControls.style.width = `${canvas.width}px`;
            }
        });

        // Add a dedicated function to update bottom controls width
        function updateBottomControlsWidth() {
            const bottomControls = document.querySelector('.bottom-controls');
            if (bottomControls && canvas) {
                // Get the actual rendered width of the canvas
                const canvasRect = canvas.getBoundingClientRect();
                
                // Set the bottom controls width to match the canvas's rendered width
                bottomControls.style.width = `${canvas.width}px`;
                
                // Also update the section inside to ensure it fills the width
                const section = bottomControls.querySelector('.bottom-controls-section');
                if (section) {
                    section.style.width = '100%';
                }
            }
        }

        // Call the update function on window resize and zoom
        window.addEventListener('resize', updateBottomControlsWidth);
        window.addEventListener('scroll', updateBottomControlsWidth); // Helps with some zoom scenarios

        // Also update on load and after any canvas size changes
        document.addEventListener('DOMContentLoaded', updateBottomControlsWidth);
        aspectRatioSelect.addEventListener('change', function() {
            updateCanvasSize();
            // Small delay to ensure canvas has updated
            setTimeout(updateBottomControlsWidth, 50);
        });

        // Add MutationObserver to detect changes to canvas size
        const canvasObserver = new MutationObserver(updateBottomControlsWidth);
        canvasObserver.observe(canvas, { attributes: true, attributeFilter: ['width', 'height', 'style'] });
        
        // Add this function near your other export-related code
        function exportCanvas() {
            console.log('Starting high-res export...');
            
            try {
                // Create a temporary high-res canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set the temp canvas to 2x size
                tempCanvas.width = canvas.width * 2;
                tempCanvas.height = canvas.height * 2;
                
                // First draw everything at normal scale
                tempCtx.save();
                tempCtx.scale(2, 2);  // Scale up all subsequent drawing operations
                
                // Draw background
                tempCtx.fillStyle = document.getElementById('backgroundColorInput').value;
                tempCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw SVG logo
                if (logoSvg && logoSvg.complete && logoSvg.naturalWidth !== 0) {
                    try {
                        const logoWidth = 100;
                        const padding = 25;
                        
                        // Get current color scheme index
                        const currentSchemeIndex = parseInt(document.getElementById('colorSchemeSelect').value) || 0;
                        const logoColor = DUOTONE_SCHEMES[currentSchemeIndex].outsidetxt;
                        
                        // Create a temporary canvas for color manipulation
                        const logoTempCanvas = document.createElement('canvas');
                        const logoTempCtx = logoTempCanvas.getContext('2d');
                        logoTempCanvas.width = logoWidth;
                        logoTempCanvas.height = logoWidth; // Use square dimensions if natural height is not available
                        
                        // Draw original SVG to temporary canvas
                        logoTempCtx.drawImage(
                            logoSvg,
                            0,
                            0,
                            logoTempCanvas.width,
                            logoTempCanvas.height
                        );
                        
                        // Get image data
                        const imageData = logoTempCtx.getImageData(0, 0, logoTempCanvas.width, logoTempCanvas.height);
                        const data = imageData.data;
                        
                        // Convert hex color to RGB
                        const hexToRgb = (hex) => {
                            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? {
                                r: parseInt(result[1], 16),
                                g: parseInt(result[2], 16),
                                b: parseInt(result[3], 16)
                            } : null;
                        };
                        
                        const targetColor = hexToRgb(logoColor);
                        
                        // Modify pixels
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i + 3] > 0) { // If pixel is not transparent
                                data[i] = targetColor.r;     // Red
                                data[i + 1] = targetColor.g; // Green
                                data[i + 2] = targetColor.b; // Blue
                                // Alpha channel (i + 3) remains unchanged
                            }
                        }
                        
                        // Put modified image data back
                        logoTempCtx.putImageData(imageData, 0, 0);
                        
                        // Draw the colored version to main canvas
                        tempCtx.drawImage(
                            logoTempCanvas,
                            padding,
                            canvas.height - logoWidth - padding,
                            logoWidth,
                            logoWidth
                        );
                        
                        // Clean up
                        logoTempCanvas.remove();
                    } catch (error) {
                        console.error('Error drawing SVG:', error);
                    }
                } else {
                    console.log('SVG not ready:', {
                        exists: !!logoSvg,
                        complete: logoSvg ? logoSvg.complete : false,
                        naturalWidth: logoSvg ? logoSvg.naturalWidth : 0
                    });
                }
                
                // Setup text properties for headers/footers
                tempCtx.textRendering = 'geometricPrecision';
                tempCtx.font = '30px YourCustomFont1';
                tempCtx.textBaseline = 'top';
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                
                // Get current color scheme
                const currentSchemeIndex = parseInt(document.getElementById('colorSchemeSelect').value) || 0;
                const textColor = DUOTONE_SCHEMES[currentSchemeIndex].outsidetxt;
                
                // Function to draw text with stroke
                function drawTextWithStroke(text, x, y) {
                    tempCtx.strokeStyle = textColor;
                    tempCtx.lineWidth = 1.5;  // Half of original since we're scaling
                    tempCtx.lineJoin = 'round';
                    tempCtx.strokeText(text, x, y);
                    
                    tempCtx.fillStyle = textColor;
                    tempCtx.fillText(text, x, y);
                }
                
                // Draw headers
                const headerText = document.getElementById('headerTextInput').value;
                tempCtx.textAlign = 'left';
                drawTextWithStroke(headerText, 20, 20);
                
                const headerText2 = document.getElementById('headerText2Input').value;
                drawTextWithStroke(headerText2, 20, 50);
                
                // Draw right headers
                const rightHeaderText = document.getElementById('rightHeaderTextInput').value;
                tempCtx.textAlign = 'right';
                drawTextWithStroke(rightHeaderText, canvas.width - 20, 20);
                
                const rightHeaderText2 = document.getElementById('rightHeaderText2Input').value;
                drawTextWithStroke(rightHeaderText2, canvas.width - 20, 50);
                
                // Draw footers
                tempCtx.textBaseline = 'bottom';
                const footer2Text = document.getElementById('footer2TextInput').value;
                drawTextWithStroke(footer2Text, canvas.width - 20, canvas.height - 50);
                
                const footerText = document.getElementById('footerTextInput').value;
                drawTextWithStroke(footerText, canvas.width - 20, canvas.height - 20);
                
                // Draw floating image
                if (floatingImage && floatingImageOscillation.physicsBody) {
                    const pos = floatingImageOscillation.physicsBody.position;
                    const width = floatingImage.width * floatingImageOscillation.scale;
                    const height = floatingImage.height * floatingImageOscillation.scale;
                    
                    tempCtx.save();
                    tempCtx.globalAlpha = floatingImageOscillation.opacity;
                    tempCtx.drawImage(
                        floatingImage,
                        pos.x - width/2,
                        pos.y - height/2,
                        width,
                        height
                    );
                    tempCtx.restore();
                }
                
                // Draw all triangles (shapes)
                [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                    letterSet.forEach(letter => {
                        if (!letter || !letter.physicsBody || !letter.trianglePoints) return;
                        
                        const shapeSize = shapeSettings.size;
                        const pos = letter.physicsBody.position;
                        
                        letter.trianglePoints.forEach(point => {
                            tempCtx.save();
                            tempCtx.fillStyle = shapeSettings.color;
                            tempCtx.translate(pos.x + point.x, pos.y + point.y);
                            tempCtx.rotate(point.rotation);
                            
                            drawShape(tempCtx, point.shape, shapeSize);
                            
                            tempCtx.restore();
                        });
                    });
                });
                
                // Draw all letter outlines
                [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                    letterSet.forEach(letter => {
                        if (!letter || !letter.physicsBody) return;
                        
                        const baseStrokeWidth = parseInt(document.getElementById('shapeStrokeWidthInput').value);
                        if (baseStrokeWidth <= 0) return;
                        
                        const scaleFactor = letter.size / letter.maxSize;
                        const scaledStrokeWidth = baseStrokeWidth * scaleFactor;
                        
                        if (letter.outlinePoints && letter.outlinePoints.length > 0) {
                            tempCtx.save();
                            tempCtx.strokeStyle = document.getElementById('triangleColorInput').value;
                            tempCtx.lineWidth = scaledStrokeWidth;
                            tempCtx.lineJoin = 'round';
                            tempCtx.lineCap = 'round';
                            
                            tempCtx.beginPath();
                            letter.outlinePoints.forEach((point, i) => {
                                const worldX = letter.x + point.relX;
                                const worldY = letter.y + point.relY;
                                
                                if (i === 0) {
                                    tempCtx.moveTo(worldX, worldY);
                                } else {
                                    tempCtx.lineTo(worldX, worldY);
                                }
                            });
                            tempCtx.closePath();
                            tempCtx.stroke();
                            tempCtx.restore();
                        }
                    });
                });
                
                // Draw all letters on top
                [letterObjects, secondLetterObjects, thirdLetterObjects].forEach(letterSet => {
                    letterSet.forEach(letter => {
                        if (!letter || !letter.physicsBody) return;
                        
                        tempCtx.save();
                        tempCtx.globalCompositeOperation = 'source-over';
                        
                        // Draw the letter fill
                        tempCtx.fillStyle = document.getElementById('letterColorInput').value;
                        tempCtx.font = `${letter.size}px ${currentFont}`;
                        tempCtx.textAlign = 'center';
                        tempCtx.textBaseline = 'middle';
                        tempCtx.fillText(letter.letter, letter.x, letter.y);
                        
                        // Draw letter stroke on top
                        const strokeWidth = parseInt(document.getElementById('strokeWidthInput').value);
                        if (strokeWidth > 0) {
                            tempCtx.strokeStyle = document.getElementById('letterColorInput').value;
                            tempCtx.lineWidth = strokeWidth;
                            tempCtx.lineJoin = 'round';
                            tempCtx.lineCap = 'round';
                            tempCtx.strokeText(letter.letter, letter.x, letter.y);
                        }
                        
                        tempCtx.restore();
                    });
                });
                
                tempCtx.restore();  // Restore the original scale
                
                // Create download link with high quality
                const dataURL = tempCanvas.toDataURL('image/jpeg', 1.0);
                const link = document.createElement('a');
                link.download = 'antwerp-on-air.jpg';
                link.href = dataURL;
                link.click();
                
                // Clean up
                tempCanvas.remove();
                console.log('High-res export completed successfully');
            } catch (error) {
                console.error('Export failed:', error);
            }
        }

        // Update the export button event listener
        document.getElementById('exportButton').addEventListener('click', exportCanvas);

        // Add this event listener near the other window/document load listeners
        window.addEventListener('load', function() {
            // Apply the first color scheme (index 0)
            applyColorScheme(0);
            
            // Also set the dropdown to show Color 1 as selected
            document.getElementById('colorSchemeSelect').value = "0";
        });

        // Add new code for video recording functionality
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let countdownInterval;

        // Create DOM elements for countdown and recording indicator
        const countdownOverlay = document.createElement('div');
        countdownOverlay.className = 'countdown-overlay';
        document.querySelector('.canvas-wrapper').appendChild(countdownOverlay);

        const recordingIndicator = document.createElement('div');
        recordingIndicator.className = 'recording-indicator';
        document.querySelector('.canvas-wrapper').appendChild(recordingIndicator);

        document.getElementById('exportButtonVideo').addEventListener('click', function() {
            if (!isRecording) {
                // Start countdown
                let countdown = 3;
                this.disabled = true;
                countdownOverlay.style.display = 'block';
                
                countdownInterval = setInterval(() => {
                    countdownOverlay.textContent = countdown;
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                        countdownOverlay.style.display = 'none';
                        startRecording();
                        this.disabled = false;
                    }
                    countdown--;
                }, 1000);
            } else {
                stopRecordingAndConvert(); // Changed this to new function
            }
        });

        function startRecording() {
            const stream = canvas.captureStream(60); // 60 FPS
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000 // 5 Mbps
            });

            mediaRecorder.ondataavailable = function(event) {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = function() {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.webm';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                recordedChunks = [];
            };

            mediaRecorder.start();
            isRecording = true;
            recordingIndicator.style.display = 'block';
            document.getElementById('exportButtonVideo').textContent = 'Stop Recording';
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordingIndicator.style.display = 'none';
                document.getElementById('exportButtonVideo').textContent = 'Export MP4';
            }
        }

        // Add Quick Export functionality
        document.getElementById('quickExportButton').addEventListener('click', async function() {
            if (!isRecording) {
                const stream = canvas.captureStream(60);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 5000000
                });
                
                recordedChunks = [];
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.start();
                isRecording = true;
                recordingIndicator.style.display = 'block';
                this.disabled = true;
                document.getElementById('exportButtonVideo').disabled = true;

                // Record for 10 seconds then stop and convert
                setTimeout(async () => {
                    if (isRecording) {
                        await stopRecordingAndConvert();
                        this.disabled = false;
                        document.getElementById('exportButtonVideo').disabled = false;
                    }
                }, 10000);
            }
        });

        // Update the existing stopRecording function to handle both buttons
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordingIndicator.style.display = 'none';
                document.getElementById('exportButtonVideo').textContent = 'Export MP4';
                document.getElementById('quickExportButton').disabled = false;
                document.getElementById('exportButtonVideo').disabled = false;
            }
        }

        // Add these functions near the start of your script
        function processInWebWorker() {
            const workerPath = 'https://granola-soymilk.github.io/aoa-tool-ver1/ffmpeg_asm.js';
            const blob = URL.createObjectURL(new Blob([`
                importScripts("${workerPath}");
                var now = Date.now;
                function print(text) {
                    postMessage({"type": "stdout", "data": text});
                }
                onmessage = function(event) {
                    var message = event.data;
                    if (message.type === "command") {
                        var Module = {
                            print: print,
                            printErr: print,
                            files: message.files || [],
                            arguments: message.arguments || [],
                            TOTAL_MEMORY: message.TOTAL_MEMORY || false
                        };
                        postMessage({"type": "start", "data": Module.arguments.join(" ")});
                        var result = ffmpeg_run(Module);
                        postMessage({"type": "done", "data": result});
                    }
                };
                postMessage({"type": "ready"});
            `], { type: 'application/javascript' }));

            const worker = new Worker(blob);
            URL.revokeObjectURL(blob);
            return worker;
        }

        function convertWebMToMP4(webmBlob) {
            return new Promise((resolve, reject) => {
                const worker = processInWebWorker();
                
                worker.onmessage = function(event) {
                    const message = event.data;
                    
                    if (message.type === "done") {
                        const result = message.data[0];
                        const mp4Blob = new Blob([result.data], { type: 'video/mp4' });
                        resolve(mp4Blob);
                    }
                };

                const reader = new FileReader();
                reader.onload = function() {
                    worker.postMessage({
                        type: 'command',
                        arguments: '-i video.webm -c:v mpeg4 -b:v 6400k -strict experimental output.mp4'.split(' '),
                        files: [{
                            data: new Uint8Array(reader.result),
                            name: 'video.webm'
                        }]
                    });
                };
                reader.readAsArrayBuffer(webmBlob);
            });
        }

        // Modify your existing export functions to use the converter
        async function exportVideo() {
            const recorder = await setupRecorder();
            recorder.startRecording();
            
            // Record for specified duration
            await new Promise(resolve => setTimeout(resolve, recordingDuration));
            
            const webmBlob = await new Promise(resolve => {
                recorder.stopRecording(() => {
                    resolve(recorder.getBlob());
                });
            });

            // Convert WebM to MP4
            const mp4Blob = await convertWebMToMP4(webmBlob);
            
            // Create download link for MP4
            const url = URL.createObjectURL(mp4Blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'animation.mp4';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Add new function to handle recording stop and conversion
        async function stopRecordingAndConvert() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                recordingIndicator.style.display = 'none';
                document.getElementById('exportButtonVideo').textContent = 'Export MP4';
                
                // Wait for all chunks to be collected
                const webmBlob = new Blob(recordedChunks, { type: 'video/webm' });
                recordedChunks = [];
                
                try {
                    // Show loading indicator
                    const loadingMessage = document.createElement('div');
                    loadingMessage.textContent = 'Converting to MP4...';
                    loadingMessage.style.position = 'fixed';
                    loadingMessage.style.top = '50%';
                    loadingMessage.style.left = '50%';
                    loadingMessage.style.transform = 'translate(-50%, -50%)';
                    loadingMessage.style.background = 'rgba(0,0,0,0.8)';
                    loadingMessage.style.color = 'white';
                    loadingMessage.style.padding = '20px';
                    loadingMessage.style.borderRadius = '5px';
                    document.body.appendChild(loadingMessage);

                    // Convert to MP4
                    const mp4Blob = await convertWebMToMP4(webmBlob);
                    
                    // Remove loading indicator
                    document.body.removeChild(loadingMessage);
                    
                    // Create download link
                    const url = URL.createObjectURL(mp4Blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'animation.mp4';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Conversion failed:', error);
                    alert('Failed to convert to MP4. Downloading WebM instead...');
                    
                    // Fallback to WebM if conversion fails
                    const url = URL.createObjectURL(webmBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'animation.webm';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }
        }

    </script>
</body>
</html>
